/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
// GENERATED CODE -- DO NOT EDIT! (generated by pbjs)
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const ConnectionProperties = $root.ConnectionProperties = (() => {

    /**
     * Properties of a ConnectionProperties.
     * @interface IConnectionProperties
     * @property {boolean|null} [isDirty] ConnectionProperties isDirty
     * @property {boolean|null} [autoCommit] ConnectionProperties autoCommit
     * @property {boolean|null} [hasAutoCommit] ConnectionProperties hasAutoCommit
     * @property {boolean|null} [readOnly] ConnectionProperties readOnly
     * @property {boolean|null} [hasReadOnly] ConnectionProperties hasReadOnly
     * @property {number|null} [transactionIsolation] ConnectionProperties transactionIsolation
     * @property {string|null} [catalog] ConnectionProperties catalog
     * @property {string|null} [schema] ConnectionProperties schema
     */

    /**
     * Constructs a new ConnectionProperties.
     * @classdesc Represents a ConnectionProperties.
     * @implements IConnectionProperties
     * @constructor
     * @param {IConnectionProperties=} [properties] Properties to set
     */
    function ConnectionProperties(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConnectionProperties isDirty.
     * @member {boolean} isDirty
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.isDirty = false;

    /**
     * ConnectionProperties autoCommit.
     * @member {boolean} autoCommit
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.autoCommit = false;

    /**
     * ConnectionProperties hasAutoCommit.
     * @member {boolean} hasAutoCommit
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.hasAutoCommit = false;

    /**
     * ConnectionProperties readOnly.
     * @member {boolean} readOnly
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.readOnly = false;

    /**
     * ConnectionProperties hasReadOnly.
     * @member {boolean} hasReadOnly
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.hasReadOnly = false;

    /**
     * ConnectionProperties transactionIsolation.
     * @member {number} transactionIsolation
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.transactionIsolation = 0;

    /**
     * ConnectionProperties catalog.
     * @member {string} catalog
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.catalog = "";

    /**
     * ConnectionProperties schema.
     * @member {string} schema
     * @memberof ConnectionProperties
     * @instance
     */
    ConnectionProperties.prototype.schema = "";

    /**
     * Creates a new ConnectionProperties instance using the specified properties.
     * @function create
     * @memberof ConnectionProperties
     * @static
     * @param {IConnectionProperties=} [properties] Properties to set
     * @returns {ConnectionProperties} ConnectionProperties instance
     */
    ConnectionProperties.create = function create(properties) {
        return new ConnectionProperties(properties);
    };

    /**
     * Encodes the specified ConnectionProperties message. Does not implicitly {@link ConnectionProperties.verify|verify} messages.
     * @function encode
     * @memberof ConnectionProperties
     * @static
     * @param {IConnectionProperties} message ConnectionProperties message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionProperties.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.isDirty != null && Object.hasOwnProperty.call(message, "isDirty"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isDirty);
        if (message.autoCommit != null && Object.hasOwnProperty.call(message, "autoCommit"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoCommit);
        if (message.readOnly != null && Object.hasOwnProperty.call(message, "readOnly"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.readOnly);
        if (message.transactionIsolation != null && Object.hasOwnProperty.call(message, "transactionIsolation"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.transactionIsolation);
        if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.catalog);
        if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.schema);
        if (message.hasAutoCommit != null && Object.hasOwnProperty.call(message, "hasAutoCommit"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasAutoCommit);
        if (message.hasReadOnly != null && Object.hasOwnProperty.call(message, "hasReadOnly"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasReadOnly);
        return writer;
    };

    /**
     * Encodes the specified ConnectionProperties message, length delimited. Does not implicitly {@link ConnectionProperties.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConnectionProperties
     * @static
     * @param {IConnectionProperties} message ConnectionProperties message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionProperties.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConnectionProperties message from the specified reader or buffer.
     * @function decode
     * @memberof ConnectionProperties
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConnectionProperties} ConnectionProperties
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionProperties.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectionProperties();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.isDirty = reader.bool();
                    break;
                }
            case 2: {
                    message.autoCommit = reader.bool();
                    break;
                }
            case 7: {
                    message.hasAutoCommit = reader.bool();
                    break;
                }
            case 3: {
                    message.readOnly = reader.bool();
                    break;
                }
            case 8: {
                    message.hasReadOnly = reader.bool();
                    break;
                }
            case 4: {
                    message.transactionIsolation = reader.uint32();
                    break;
                }
            case 5: {
                    message.catalog = reader.string();
                    break;
                }
            case 6: {
                    message.schema = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConnectionProperties message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConnectionProperties
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConnectionProperties} ConnectionProperties
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionProperties.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConnectionProperties message.
     * @function verify
     * @memberof ConnectionProperties
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConnectionProperties.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.isDirty != null && message.hasOwnProperty("isDirty"))
            if (typeof message.isDirty !== "boolean")
                return "isDirty: boolean expected";
        if (message.autoCommit != null && message.hasOwnProperty("autoCommit"))
            if (typeof message.autoCommit !== "boolean")
                return "autoCommit: boolean expected";
        if (message.hasAutoCommit != null && message.hasOwnProperty("hasAutoCommit"))
            if (typeof message.hasAutoCommit !== "boolean")
                return "hasAutoCommit: boolean expected";
        if (message.readOnly != null && message.hasOwnProperty("readOnly"))
            if (typeof message.readOnly !== "boolean")
                return "readOnly: boolean expected";
        if (message.hasReadOnly != null && message.hasOwnProperty("hasReadOnly"))
            if (typeof message.hasReadOnly !== "boolean")
                return "hasReadOnly: boolean expected";
        if (message.transactionIsolation != null && message.hasOwnProperty("transactionIsolation"))
            if (!$util.isInteger(message.transactionIsolation))
                return "transactionIsolation: integer expected";
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            if (!$util.isString(message.catalog))
                return "catalog: string expected";
        if (message.schema != null && message.hasOwnProperty("schema"))
            if (!$util.isString(message.schema))
                return "schema: string expected";
        return null;
    };

    /**
     * Creates a ConnectionProperties message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConnectionProperties
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConnectionProperties} ConnectionProperties
     */
    ConnectionProperties.fromObject = function fromObject(object) {
        if (object instanceof $root.ConnectionProperties)
            return object;
        let message = new $root.ConnectionProperties();
        if (object.isDirty != null)
            message.isDirty = Boolean(object.isDirty);
        if (object.autoCommit != null)
            message.autoCommit = Boolean(object.autoCommit);
        if (object.hasAutoCommit != null)
            message.hasAutoCommit = Boolean(object.hasAutoCommit);
        if (object.readOnly != null)
            message.readOnly = Boolean(object.readOnly);
        if (object.hasReadOnly != null)
            message.hasReadOnly = Boolean(object.hasReadOnly);
        if (object.transactionIsolation != null)
            message.transactionIsolation = object.transactionIsolation >>> 0;
        if (object.catalog != null)
            message.catalog = String(object.catalog);
        if (object.schema != null)
            message.schema = String(object.schema);
        return message;
    };

    /**
     * Creates a plain object from a ConnectionProperties message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConnectionProperties
     * @static
     * @param {ConnectionProperties} message ConnectionProperties
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConnectionProperties.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.isDirty = false;
            object.autoCommit = false;
            object.readOnly = false;
            object.transactionIsolation = 0;
            object.catalog = "";
            object.schema = "";
            object.hasAutoCommit = false;
            object.hasReadOnly = false;
        }
        if (message.isDirty != null && message.hasOwnProperty("isDirty"))
            object.isDirty = message.isDirty;
        if (message.autoCommit != null && message.hasOwnProperty("autoCommit"))
            object.autoCommit = message.autoCommit;
        if (message.readOnly != null && message.hasOwnProperty("readOnly"))
            object.readOnly = message.readOnly;
        if (message.transactionIsolation != null && message.hasOwnProperty("transactionIsolation"))
            object.transactionIsolation = message.transactionIsolation;
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            object.catalog = message.catalog;
        if (message.schema != null && message.hasOwnProperty("schema"))
            object.schema = message.schema;
        if (message.hasAutoCommit != null && message.hasOwnProperty("hasAutoCommit"))
            object.hasAutoCommit = message.hasAutoCommit;
        if (message.hasReadOnly != null && message.hasOwnProperty("hasReadOnly"))
            object.hasReadOnly = message.hasReadOnly;
        return object;
    };

    /**
     * Converts this ConnectionProperties to JSON.
     * @function toJSON
     * @memberof ConnectionProperties
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConnectionProperties.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ConnectionProperties
     * @function getTypeUrl
     * @memberof ConnectionProperties
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ConnectionProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ConnectionProperties";
    };

    return ConnectionProperties;
})();

export const StatementHandle = $root.StatementHandle = (() => {

    /**
     * Properties of a StatementHandle.
     * @interface IStatementHandle
     * @property {string|null} [connectionId] StatementHandle connectionId
     * @property {number|null} [id] StatementHandle id
     * @property {ISignature|null} [signature] StatementHandle signature
     */

    /**
     * Constructs a new StatementHandle.
     * @classdesc Represents a StatementHandle.
     * @implements IStatementHandle
     * @constructor
     * @param {IStatementHandle=} [properties] Properties to set
     */
    function StatementHandle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * StatementHandle connectionId.
     * @member {string} connectionId
     * @memberof StatementHandle
     * @instance
     */
    StatementHandle.prototype.connectionId = "";

    /**
     * StatementHandle id.
     * @member {number} id
     * @memberof StatementHandle
     * @instance
     */
    StatementHandle.prototype.id = 0;

    /**
     * StatementHandle signature.
     * @member {ISignature|null|undefined} signature
     * @memberof StatementHandle
     * @instance
     */
    StatementHandle.prototype.signature = null;

    /**
     * Creates a new StatementHandle instance using the specified properties.
     * @function create
     * @memberof StatementHandle
     * @static
     * @param {IStatementHandle=} [properties] Properties to set
     * @returns {StatementHandle} StatementHandle instance
     */
    StatementHandle.create = function create(properties) {
        return new StatementHandle(properties);
    };

    /**
     * Encodes the specified StatementHandle message. Does not implicitly {@link StatementHandle.verify|verify} messages.
     * @function encode
     * @memberof StatementHandle
     * @static
     * @param {IStatementHandle} message StatementHandle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StatementHandle.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified StatementHandle message, length delimited. Does not implicitly {@link StatementHandle.verify|verify} messages.
     * @function encodeDelimited
     * @memberof StatementHandle
     * @static
     * @param {IStatementHandle} message StatementHandle message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    StatementHandle.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a StatementHandle message from the specified reader or buffer.
     * @function decode
     * @memberof StatementHandle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {StatementHandle} StatementHandle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StatementHandle.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatementHandle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.id = reader.uint32();
                    break;
                }
            case 3: {
                    message.signature = $root.Signature.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a StatementHandle message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof StatementHandle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {StatementHandle} StatementHandle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    StatementHandle.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a StatementHandle message.
     * @function verify
     * @memberof StatementHandle
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    StatementHandle.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.signature != null && message.hasOwnProperty("signature")) {
            let error = $root.Signature.verify(message.signature);
            if (error)
                return "signature." + error;
        }
        return null;
    };

    /**
     * Creates a StatementHandle message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof StatementHandle
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {StatementHandle} StatementHandle
     */
    StatementHandle.fromObject = function fromObject(object) {
        if (object instanceof $root.StatementHandle)
            return object;
        let message = new $root.StatementHandle();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.signature != null) {
            if (typeof object.signature !== "object")
                throw TypeError(".StatementHandle.signature: object expected");
            message.signature = $root.Signature.fromObject(object.signature);
        }
        return message;
    };

    /**
     * Creates a plain object from a StatementHandle message. Also converts values to other types if specified.
     * @function toObject
     * @memberof StatementHandle
     * @static
     * @param {StatementHandle} message StatementHandle
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    StatementHandle.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.id = 0;
            object.signature = null;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.Signature.toObject(message.signature, options);
        return object;
    };

    /**
     * Converts this StatementHandle to JSON.
     * @function toJSON
     * @memberof StatementHandle
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    StatementHandle.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for StatementHandle
     * @function getTypeUrl
     * @memberof StatementHandle
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    StatementHandle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/StatementHandle";
    };

    return StatementHandle;
})();

export const Signature = $root.Signature = (() => {

    /**
     * Properties of a Signature.
     * @interface ISignature
     * @property {Array.<IColumnMetaData>|null} [columns] Signature columns
     * @property {string|null} [sql] Signature sql
     * @property {Array.<IAvaticaParameter>|null} [parameters] Signature parameters
     * @property {ICursorFactory|null} [cursorFactory] Signature cursorFactory
     * @property {StatementType|null} [statementType] Signature statementType
     */

    /**
     * Constructs a new Signature.
     * @classdesc Represents a Signature.
     * @implements ISignature
     * @constructor
     * @param {ISignature=} [properties] Properties to set
     */
    function Signature(properties) {
        this.columns = [];
        this.parameters = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Signature columns.
     * @member {Array.<IColumnMetaData>} columns
     * @memberof Signature
     * @instance
     */
    Signature.prototype.columns = $util.emptyArray;

    /**
     * Signature sql.
     * @member {string} sql
     * @memberof Signature
     * @instance
     */
    Signature.prototype.sql = "";

    /**
     * Signature parameters.
     * @member {Array.<IAvaticaParameter>} parameters
     * @memberof Signature
     * @instance
     */
    Signature.prototype.parameters = $util.emptyArray;

    /**
     * Signature cursorFactory.
     * @member {ICursorFactory|null|undefined} cursorFactory
     * @memberof Signature
     * @instance
     */
    Signature.prototype.cursorFactory = null;

    /**
     * Signature statementType.
     * @member {StatementType} statementType
     * @memberof Signature
     * @instance
     */
    Signature.prototype.statementType = 0;

    /**
     * Creates a new Signature instance using the specified properties.
     * @function create
     * @memberof Signature
     * @static
     * @param {ISignature=} [properties] Properties to set
     * @returns {Signature} Signature instance
     */
    Signature.create = function create(properties) {
        return new Signature(properties);
    };

    /**
     * Encodes the specified Signature message. Does not implicitly {@link Signature.verify|verify} messages.
     * @function encode
     * @memberof Signature
     * @static
     * @param {ISignature} message Signature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Signature.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.columns != null && message.columns.length)
            for (let i = 0; i < message.columns.length; ++i)
                $root.ColumnMetaData.encode(message.columns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sql);
        if (message.parameters != null && message.parameters.length)
            for (let i = 0; i < message.parameters.length; ++i)
                $root.AvaticaParameter.encode(message.parameters[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.cursorFactory != null && Object.hasOwnProperty.call(message, "cursorFactory"))
            $root.CursorFactory.encode(message.cursorFactory, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.statementType != null && Object.hasOwnProperty.call(message, "statementType"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.statementType);
        return writer;
    };

    /**
     * Encodes the specified Signature message, length delimited. Does not implicitly {@link Signature.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Signature
     * @static
     * @param {ISignature} message Signature message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Signature.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Signature message from the specified reader or buffer.
     * @function decode
     * @memberof Signature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Signature} Signature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Signature.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Signature();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.ColumnMetaData.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    message.sql = reader.string();
                    break;
                }
            case 3: {
                    if (!(message.parameters && message.parameters.length))
                        message.parameters = [];
                    message.parameters.push($root.AvaticaParameter.decode(reader, reader.uint32()));
                    break;
                }
            case 4: {
                    message.cursorFactory = $root.CursorFactory.decode(reader, reader.uint32());
                    break;
                }
            case 5: {
                    message.statementType = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Signature message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Signature
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Signature} Signature
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Signature.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Signature message.
     * @function verify
     * @memberof Signature
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Signature.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.columns != null && message.hasOwnProperty("columns")) {
            if (!Array.isArray(message.columns))
                return "columns: array expected";
            for (let i = 0; i < message.columns.length; ++i) {
                let error = $root.ColumnMetaData.verify(message.columns[i]);
                if (error)
                    return "columns." + error;
            }
        }
        if (message.sql != null && message.hasOwnProperty("sql"))
            if (!$util.isString(message.sql))
                return "sql: string expected";
        if (message.parameters != null && message.hasOwnProperty("parameters")) {
            if (!Array.isArray(message.parameters))
                return "parameters: array expected";
            for (let i = 0; i < message.parameters.length; ++i) {
                let error = $root.AvaticaParameter.verify(message.parameters[i]);
                if (error)
                    return "parameters." + error;
            }
        }
        if (message.cursorFactory != null && message.hasOwnProperty("cursorFactory")) {
            let error = $root.CursorFactory.verify(message.cursorFactory);
            if (error)
                return "cursorFactory." + error;
        }
        if (message.statementType != null && message.hasOwnProperty("statementType"))
            switch (message.statementType) {
            default:
                return "statementType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
                break;
            }
        return null;
    };

    /**
     * Creates a Signature message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Signature
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Signature} Signature
     */
    Signature.fromObject = function fromObject(object) {
        if (object instanceof $root.Signature)
            return object;
        let message = new $root.Signature();
        if (object.columns) {
            if (!Array.isArray(object.columns))
                throw TypeError(".Signature.columns: array expected");
            message.columns = [];
            for (let i = 0; i < object.columns.length; ++i) {
                if (typeof object.columns[i] !== "object")
                    throw TypeError(".Signature.columns: object expected");
                message.columns[i] = $root.ColumnMetaData.fromObject(object.columns[i]);
            }
        }
        if (object.sql != null)
            message.sql = String(object.sql);
        if (object.parameters) {
            if (!Array.isArray(object.parameters))
                throw TypeError(".Signature.parameters: array expected");
            message.parameters = [];
            for (let i = 0; i < object.parameters.length; ++i) {
                if (typeof object.parameters[i] !== "object")
                    throw TypeError(".Signature.parameters: object expected");
                message.parameters[i] = $root.AvaticaParameter.fromObject(object.parameters[i]);
            }
        }
        if (object.cursorFactory != null) {
            if (typeof object.cursorFactory !== "object")
                throw TypeError(".Signature.cursorFactory: object expected");
            message.cursorFactory = $root.CursorFactory.fromObject(object.cursorFactory);
        }
        switch (object.statementType) {
        default:
            if (typeof object.statementType === "number") {
                message.statementType = object.statementType;
                break;
            }
            break;
        case "SELECT":
        case 0:
            message.statementType = 0;
            break;
        case "INSERT":
        case 1:
            message.statementType = 1;
            break;
        case "UPDATE":
        case 2:
            message.statementType = 2;
            break;
        case "DELETE":
        case 3:
            message.statementType = 3;
            break;
        case "UPSERT":
        case 4:
            message.statementType = 4;
            break;
        case "MERGE":
        case 5:
            message.statementType = 5;
            break;
        case "OTHER_DML":
        case 6:
            message.statementType = 6;
            break;
        case "CREATE":
        case 7:
            message.statementType = 7;
            break;
        case "DROP":
        case 8:
            message.statementType = 8;
            break;
        case "ALTER":
        case 9:
            message.statementType = 9;
            break;
        case "OTHER_DDL":
        case 10:
            message.statementType = 10;
            break;
        case "CALL":
        case 11:
            message.statementType = 11;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a Signature message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Signature
     * @static
     * @param {Signature} message Signature
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Signature.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.columns = [];
            object.parameters = [];
        }
        if (options.defaults) {
            object.sql = "";
            object.cursorFactory = null;
            object.statementType = options.enums === String ? "SELECT" : 0;
        }
        if (message.columns && message.columns.length) {
            object.columns = [];
            for (let j = 0; j < message.columns.length; ++j)
                object.columns[j] = $root.ColumnMetaData.toObject(message.columns[j], options);
        }
        if (message.sql != null && message.hasOwnProperty("sql"))
            object.sql = message.sql;
        if (message.parameters && message.parameters.length) {
            object.parameters = [];
            for (let j = 0; j < message.parameters.length; ++j)
                object.parameters[j] = $root.AvaticaParameter.toObject(message.parameters[j], options);
        }
        if (message.cursorFactory != null && message.hasOwnProperty("cursorFactory"))
            object.cursorFactory = $root.CursorFactory.toObject(message.cursorFactory, options);
        if (message.statementType != null && message.hasOwnProperty("statementType"))
            object.statementType = options.enums === String ? $root.StatementType[message.statementType] === undefined ? message.statementType : $root.StatementType[message.statementType] : message.statementType;
        return object;
    };

    /**
     * Converts this Signature to JSON.
     * @function toJSON
     * @memberof Signature
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Signature.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Signature
     * @function getTypeUrl
     * @memberof Signature
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Signature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Signature";
    };

    return Signature;
})();

/**
 * StatementType enum.
 * @enum {number}
 * @property {number} SELECT=0 SELECT value
 * @property {number} INSERT=1 INSERT value
 * @property {number} UPDATE=2 UPDATE value
 * @property {number} DELETE=3 DELETE value
 * @property {number} UPSERT=4 UPSERT value
 * @property {number} MERGE=5 MERGE value
 * @property {number} OTHER_DML=6 OTHER_DML value
 * @property {number} CREATE=7 CREATE value
 * @property {number} DROP=8 DROP value
 * @property {number} ALTER=9 ALTER value
 * @property {number} OTHER_DDL=10 OTHER_DDL value
 * @property {number} CALL=11 CALL value
 */
export const StatementType = $root.StatementType = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SELECT"] = 0;
    values[valuesById[1] = "INSERT"] = 1;
    values[valuesById[2] = "UPDATE"] = 2;
    values[valuesById[3] = "DELETE"] = 3;
    values[valuesById[4] = "UPSERT"] = 4;
    values[valuesById[5] = "MERGE"] = 5;
    values[valuesById[6] = "OTHER_DML"] = 6;
    values[valuesById[7] = "CREATE"] = 7;
    values[valuesById[8] = "DROP"] = 8;
    values[valuesById[9] = "ALTER"] = 9;
    values[valuesById[10] = "OTHER_DDL"] = 10;
    values[valuesById[11] = "CALL"] = 11;
    return values;
})();

export const ColumnMetaData = $root.ColumnMetaData = (() => {

    /**
     * Properties of a ColumnMetaData.
     * @interface IColumnMetaData
     * @property {number|null} [ordinal] ColumnMetaData ordinal
     * @property {boolean|null} [autoIncrement] ColumnMetaData autoIncrement
     * @property {boolean|null} [caseSensitive] ColumnMetaData caseSensitive
     * @property {boolean|null} [searchable] ColumnMetaData searchable
     * @property {boolean|null} [currency] ColumnMetaData currency
     * @property {number|null} [nullable] ColumnMetaData nullable
     * @property {boolean|null} [signed] ColumnMetaData signed
     * @property {number|null} [displaySize] ColumnMetaData displaySize
     * @property {string|null} [label] ColumnMetaData label
     * @property {string|null} [columnName] ColumnMetaData columnName
     * @property {string|null} [schemaName] ColumnMetaData schemaName
     * @property {number|null} [precision] ColumnMetaData precision
     * @property {number|null} [scale] ColumnMetaData scale
     * @property {string|null} [tableName] ColumnMetaData tableName
     * @property {string|null} [catalogName] ColumnMetaData catalogName
     * @property {boolean|null} [readOnly] ColumnMetaData readOnly
     * @property {boolean|null} [writable] ColumnMetaData writable
     * @property {boolean|null} [definitelyWritable] ColumnMetaData definitelyWritable
     * @property {string|null} [columnClassName] ColumnMetaData columnClassName
     * @property {IAvaticaType|null} [type] ColumnMetaData type
     */

    /**
     * Constructs a new ColumnMetaData.
     * @classdesc Represents a ColumnMetaData.
     * @implements IColumnMetaData
     * @constructor
     * @param {IColumnMetaData=} [properties] Properties to set
     */
    function ColumnMetaData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ColumnMetaData ordinal.
     * @member {number} ordinal
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.ordinal = 0;

    /**
     * ColumnMetaData autoIncrement.
     * @member {boolean} autoIncrement
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.autoIncrement = false;

    /**
     * ColumnMetaData caseSensitive.
     * @member {boolean} caseSensitive
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.caseSensitive = false;

    /**
     * ColumnMetaData searchable.
     * @member {boolean} searchable
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.searchable = false;

    /**
     * ColumnMetaData currency.
     * @member {boolean} currency
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.currency = false;

    /**
     * ColumnMetaData nullable.
     * @member {number} nullable
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.nullable = 0;

    /**
     * ColumnMetaData signed.
     * @member {boolean} signed
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.signed = false;

    /**
     * ColumnMetaData displaySize.
     * @member {number} displaySize
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.displaySize = 0;

    /**
     * ColumnMetaData label.
     * @member {string} label
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.label = "";

    /**
     * ColumnMetaData columnName.
     * @member {string} columnName
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.columnName = "";

    /**
     * ColumnMetaData schemaName.
     * @member {string} schemaName
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.schemaName = "";

    /**
     * ColumnMetaData precision.
     * @member {number} precision
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.precision = 0;

    /**
     * ColumnMetaData scale.
     * @member {number} scale
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.scale = 0;

    /**
     * ColumnMetaData tableName.
     * @member {string} tableName
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.tableName = "";

    /**
     * ColumnMetaData catalogName.
     * @member {string} catalogName
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.catalogName = "";

    /**
     * ColumnMetaData readOnly.
     * @member {boolean} readOnly
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.readOnly = false;

    /**
     * ColumnMetaData writable.
     * @member {boolean} writable
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.writable = false;

    /**
     * ColumnMetaData definitelyWritable.
     * @member {boolean} definitelyWritable
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.definitelyWritable = false;

    /**
     * ColumnMetaData columnClassName.
     * @member {string} columnClassName
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.columnClassName = "";

    /**
     * ColumnMetaData type.
     * @member {IAvaticaType|null|undefined} type
     * @memberof ColumnMetaData
     * @instance
     */
    ColumnMetaData.prototype.type = null;

    /**
     * Creates a new ColumnMetaData instance using the specified properties.
     * @function create
     * @memberof ColumnMetaData
     * @static
     * @param {IColumnMetaData=} [properties] Properties to set
     * @returns {ColumnMetaData} ColumnMetaData instance
     */
    ColumnMetaData.create = function create(properties) {
        return new ColumnMetaData(properties);
    };

    /**
     * Encodes the specified ColumnMetaData message. Does not implicitly {@link ColumnMetaData.verify|verify} messages.
     * @function encode
     * @memberof ColumnMetaData
     * @static
     * @param {IColumnMetaData} message ColumnMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnMetaData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.ordinal != null && Object.hasOwnProperty.call(message, "ordinal"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ordinal);
        if (message.autoIncrement != null && Object.hasOwnProperty.call(message, "autoIncrement"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.autoIncrement);
        if (message.caseSensitive != null && Object.hasOwnProperty.call(message, "caseSensitive"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.caseSensitive);
        if (message.searchable != null && Object.hasOwnProperty.call(message, "searchable"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.searchable);
        if (message.currency != null && Object.hasOwnProperty.call(message, "currency"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.currency);
        if (message.nullable != null && Object.hasOwnProperty.call(message, "nullable"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.nullable);
        if (message.signed != null && Object.hasOwnProperty.call(message, "signed"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.signed);
        if (message.displaySize != null && Object.hasOwnProperty.call(message, "displaySize"))
            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.displaySize);
        if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(/* id 9, wireType 2 =*/74).string(message.label);
        if (message.columnName != null && Object.hasOwnProperty.call(message, "columnName"))
            writer.uint32(/* id 10, wireType 2 =*/82).string(message.columnName);
        if (message.schemaName != null && Object.hasOwnProperty.call(message, "schemaName"))
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.schemaName);
        if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.precision);
        if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
            writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.scale);
        if (message.tableName != null && Object.hasOwnProperty.call(message, "tableName"))
            writer.uint32(/* id 14, wireType 2 =*/114).string(message.tableName);
        if (message.catalogName != null && Object.hasOwnProperty.call(message, "catalogName"))
            writer.uint32(/* id 15, wireType 2 =*/122).string(message.catalogName);
        if (message.readOnly != null && Object.hasOwnProperty.call(message, "readOnly"))
            writer.uint32(/* id 16, wireType 0 =*/128).bool(message.readOnly);
        if (message.writable != null && Object.hasOwnProperty.call(message, "writable"))
            writer.uint32(/* id 17, wireType 0 =*/136).bool(message.writable);
        if (message.definitelyWritable != null && Object.hasOwnProperty.call(message, "definitelyWritable"))
            writer.uint32(/* id 18, wireType 0 =*/144).bool(message.definitelyWritable);
        if (message.columnClassName != null && Object.hasOwnProperty.call(message, "columnClassName"))
            writer.uint32(/* id 19, wireType 2 =*/154).string(message.columnClassName);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            $root.AvaticaType.encode(message.type, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ColumnMetaData message, length delimited. Does not implicitly {@link ColumnMetaData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ColumnMetaData
     * @static
     * @param {IColumnMetaData} message ColumnMetaData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnMetaData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ColumnMetaData message from the specified reader or buffer.
     * @function decode
     * @memberof ColumnMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ColumnMetaData} ColumnMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnMetaData.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ColumnMetaData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.ordinal = reader.uint32();
                    break;
                }
            case 2: {
                    message.autoIncrement = reader.bool();
                    break;
                }
            case 3: {
                    message.caseSensitive = reader.bool();
                    break;
                }
            case 4: {
                    message.searchable = reader.bool();
                    break;
                }
            case 5: {
                    message.currency = reader.bool();
                    break;
                }
            case 6: {
                    message.nullable = reader.uint32();
                    break;
                }
            case 7: {
                    message.signed = reader.bool();
                    break;
                }
            case 8: {
                    message.displaySize = reader.uint32();
                    break;
                }
            case 9: {
                    message.label = reader.string();
                    break;
                }
            case 10: {
                    message.columnName = reader.string();
                    break;
                }
            case 11: {
                    message.schemaName = reader.string();
                    break;
                }
            case 12: {
                    message.precision = reader.uint32();
                    break;
                }
            case 13: {
                    message.scale = reader.uint32();
                    break;
                }
            case 14: {
                    message.tableName = reader.string();
                    break;
                }
            case 15: {
                    message.catalogName = reader.string();
                    break;
                }
            case 16: {
                    message.readOnly = reader.bool();
                    break;
                }
            case 17: {
                    message.writable = reader.bool();
                    break;
                }
            case 18: {
                    message.definitelyWritable = reader.bool();
                    break;
                }
            case 19: {
                    message.columnClassName = reader.string();
                    break;
                }
            case 20: {
                    message.type = $root.AvaticaType.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ColumnMetaData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ColumnMetaData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ColumnMetaData} ColumnMetaData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnMetaData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ColumnMetaData message.
     * @function verify
     * @memberof ColumnMetaData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ColumnMetaData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.ordinal != null && message.hasOwnProperty("ordinal"))
            if (!$util.isInteger(message.ordinal))
                return "ordinal: integer expected";
        if (message.autoIncrement != null && message.hasOwnProperty("autoIncrement"))
            if (typeof message.autoIncrement !== "boolean")
                return "autoIncrement: boolean expected";
        if (message.caseSensitive != null && message.hasOwnProperty("caseSensitive"))
            if (typeof message.caseSensitive !== "boolean")
                return "caseSensitive: boolean expected";
        if (message.searchable != null && message.hasOwnProperty("searchable"))
            if (typeof message.searchable !== "boolean")
                return "searchable: boolean expected";
        if (message.currency != null && message.hasOwnProperty("currency"))
            if (typeof message.currency !== "boolean")
                return "currency: boolean expected";
        if (message.nullable != null && message.hasOwnProperty("nullable"))
            if (!$util.isInteger(message.nullable))
                return "nullable: integer expected";
        if (message.signed != null && message.hasOwnProperty("signed"))
            if (typeof message.signed !== "boolean")
                return "signed: boolean expected";
        if (message.displaySize != null && message.hasOwnProperty("displaySize"))
            if (!$util.isInteger(message.displaySize))
                return "displaySize: integer expected";
        if (message.label != null && message.hasOwnProperty("label"))
            if (!$util.isString(message.label))
                return "label: string expected";
        if (message.columnName != null && message.hasOwnProperty("columnName"))
            if (!$util.isString(message.columnName))
                return "columnName: string expected";
        if (message.schemaName != null && message.hasOwnProperty("schemaName"))
            if (!$util.isString(message.schemaName))
                return "schemaName: string expected";
        if (message.precision != null && message.hasOwnProperty("precision"))
            if (!$util.isInteger(message.precision))
                return "precision: integer expected";
        if (message.scale != null && message.hasOwnProperty("scale"))
            if (!$util.isInteger(message.scale))
                return "scale: integer expected";
        if (message.tableName != null && message.hasOwnProperty("tableName"))
            if (!$util.isString(message.tableName))
                return "tableName: string expected";
        if (message.catalogName != null && message.hasOwnProperty("catalogName"))
            if (!$util.isString(message.catalogName))
                return "catalogName: string expected";
        if (message.readOnly != null && message.hasOwnProperty("readOnly"))
            if (typeof message.readOnly !== "boolean")
                return "readOnly: boolean expected";
        if (message.writable != null && message.hasOwnProperty("writable"))
            if (typeof message.writable !== "boolean")
                return "writable: boolean expected";
        if (message.definitelyWritable != null && message.hasOwnProperty("definitelyWritable"))
            if (typeof message.definitelyWritable !== "boolean")
                return "definitelyWritable: boolean expected";
        if (message.columnClassName != null && message.hasOwnProperty("columnClassName"))
            if (!$util.isString(message.columnClassName))
                return "columnClassName: string expected";
        if (message.type != null && message.hasOwnProperty("type")) {
            let error = $root.AvaticaType.verify(message.type);
            if (error)
                return "type." + error;
        }
        return null;
    };

    /**
     * Creates a ColumnMetaData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ColumnMetaData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ColumnMetaData} ColumnMetaData
     */
    ColumnMetaData.fromObject = function fromObject(object) {
        if (object instanceof $root.ColumnMetaData)
            return object;
        let message = new $root.ColumnMetaData();
        if (object.ordinal != null)
            message.ordinal = object.ordinal >>> 0;
        if (object.autoIncrement != null)
            message.autoIncrement = Boolean(object.autoIncrement);
        if (object.caseSensitive != null)
            message.caseSensitive = Boolean(object.caseSensitive);
        if (object.searchable != null)
            message.searchable = Boolean(object.searchable);
        if (object.currency != null)
            message.currency = Boolean(object.currency);
        if (object.nullable != null)
            message.nullable = object.nullable >>> 0;
        if (object.signed != null)
            message.signed = Boolean(object.signed);
        if (object.displaySize != null)
            message.displaySize = object.displaySize >>> 0;
        if (object.label != null)
            message.label = String(object.label);
        if (object.columnName != null)
            message.columnName = String(object.columnName);
        if (object.schemaName != null)
            message.schemaName = String(object.schemaName);
        if (object.precision != null)
            message.precision = object.precision >>> 0;
        if (object.scale != null)
            message.scale = object.scale >>> 0;
        if (object.tableName != null)
            message.tableName = String(object.tableName);
        if (object.catalogName != null)
            message.catalogName = String(object.catalogName);
        if (object.readOnly != null)
            message.readOnly = Boolean(object.readOnly);
        if (object.writable != null)
            message.writable = Boolean(object.writable);
        if (object.definitelyWritable != null)
            message.definitelyWritable = Boolean(object.definitelyWritable);
        if (object.columnClassName != null)
            message.columnClassName = String(object.columnClassName);
        if (object.type != null) {
            if (typeof object.type !== "object")
                throw TypeError(".ColumnMetaData.type: object expected");
            message.type = $root.AvaticaType.fromObject(object.type);
        }
        return message;
    };

    /**
     * Creates a plain object from a ColumnMetaData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ColumnMetaData
     * @static
     * @param {ColumnMetaData} message ColumnMetaData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ColumnMetaData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.ordinal = 0;
            object.autoIncrement = false;
            object.caseSensitive = false;
            object.searchable = false;
            object.currency = false;
            object.nullable = 0;
            object.signed = false;
            object.displaySize = 0;
            object.label = "";
            object.columnName = "";
            object.schemaName = "";
            object.precision = 0;
            object.scale = 0;
            object.tableName = "";
            object.catalogName = "";
            object.readOnly = false;
            object.writable = false;
            object.definitelyWritable = false;
            object.columnClassName = "";
            object.type = null;
        }
        if (message.ordinal != null && message.hasOwnProperty("ordinal"))
            object.ordinal = message.ordinal;
        if (message.autoIncrement != null && message.hasOwnProperty("autoIncrement"))
            object.autoIncrement = message.autoIncrement;
        if (message.caseSensitive != null && message.hasOwnProperty("caseSensitive"))
            object.caseSensitive = message.caseSensitive;
        if (message.searchable != null && message.hasOwnProperty("searchable"))
            object.searchable = message.searchable;
        if (message.currency != null && message.hasOwnProperty("currency"))
            object.currency = message.currency;
        if (message.nullable != null && message.hasOwnProperty("nullable"))
            object.nullable = message.nullable;
        if (message.signed != null && message.hasOwnProperty("signed"))
            object.signed = message.signed;
        if (message.displaySize != null && message.hasOwnProperty("displaySize"))
            object.displaySize = message.displaySize;
        if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
        if (message.columnName != null && message.hasOwnProperty("columnName"))
            object.columnName = message.columnName;
        if (message.schemaName != null && message.hasOwnProperty("schemaName"))
            object.schemaName = message.schemaName;
        if (message.precision != null && message.hasOwnProperty("precision"))
            object.precision = message.precision;
        if (message.scale != null && message.hasOwnProperty("scale"))
            object.scale = message.scale;
        if (message.tableName != null && message.hasOwnProperty("tableName"))
            object.tableName = message.tableName;
        if (message.catalogName != null && message.hasOwnProperty("catalogName"))
            object.catalogName = message.catalogName;
        if (message.readOnly != null && message.hasOwnProperty("readOnly"))
            object.readOnly = message.readOnly;
        if (message.writable != null && message.hasOwnProperty("writable"))
            object.writable = message.writable;
        if (message.definitelyWritable != null && message.hasOwnProperty("definitelyWritable"))
            object.definitelyWritable = message.definitelyWritable;
        if (message.columnClassName != null && message.hasOwnProperty("columnClassName"))
            object.columnClassName = message.columnClassName;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = $root.AvaticaType.toObject(message.type, options);
        return object;
    };

    /**
     * Converts this ColumnMetaData to JSON.
     * @function toJSON
     * @memberof ColumnMetaData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ColumnMetaData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ColumnMetaData
     * @function getTypeUrl
     * @memberof ColumnMetaData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ColumnMetaData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ColumnMetaData";
    };

    return ColumnMetaData;
})();

/**
 * Rep enum.
 * @enum {number}
 * @property {number} PRIMITIVE_BOOLEAN=0 PRIMITIVE_BOOLEAN value
 * @property {number} PRIMITIVE_BYTE=1 PRIMITIVE_BYTE value
 * @property {number} PRIMITIVE_CHAR=2 PRIMITIVE_CHAR value
 * @property {number} PRIMITIVE_SHORT=3 PRIMITIVE_SHORT value
 * @property {number} PRIMITIVE_INT=4 PRIMITIVE_INT value
 * @property {number} PRIMITIVE_LONG=5 PRIMITIVE_LONG value
 * @property {number} PRIMITIVE_FLOAT=6 PRIMITIVE_FLOAT value
 * @property {number} PRIMITIVE_DOUBLE=7 PRIMITIVE_DOUBLE value
 * @property {number} BOOLEAN=8 BOOLEAN value
 * @property {number} BYTE=9 BYTE value
 * @property {number} CHARACTER=10 CHARACTER value
 * @property {number} SHORT=11 SHORT value
 * @property {number} INTEGER=12 INTEGER value
 * @property {number} LONG=13 LONG value
 * @property {number} FLOAT=14 FLOAT value
 * @property {number} DOUBLE=15 DOUBLE value
 * @property {number} BIG_INTEGER=25 BIG_INTEGER value
 * @property {number} BIG_DECIMAL=26 BIG_DECIMAL value
 * @property {number} JAVA_SQL_TIME=16 JAVA_SQL_TIME value
 * @property {number} JAVA_SQL_TIMESTAMP=17 JAVA_SQL_TIMESTAMP value
 * @property {number} JAVA_SQL_DATE=18 JAVA_SQL_DATE value
 * @property {number} JAVA_UTIL_DATE=19 JAVA_UTIL_DATE value
 * @property {number} BYTE_STRING=20 BYTE_STRING value
 * @property {number} STRING=21 STRING value
 * @property {number} NUMBER=22 NUMBER value
 * @property {number} OBJECT=23 OBJECT value
 * @property {number} NULL=24 NULL value
 * @property {number} ARRAY=27 ARRAY value
 * @property {number} STRUCT=28 STRUCT value
 * @property {number} MULTISET=29 MULTISET value
 */
export const Rep = $root.Rep = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "PRIMITIVE_BOOLEAN"] = 0;
    values[valuesById[1] = "PRIMITIVE_BYTE"] = 1;
    values[valuesById[2] = "PRIMITIVE_CHAR"] = 2;
    values[valuesById[3] = "PRIMITIVE_SHORT"] = 3;
    values[valuesById[4] = "PRIMITIVE_INT"] = 4;
    values[valuesById[5] = "PRIMITIVE_LONG"] = 5;
    values[valuesById[6] = "PRIMITIVE_FLOAT"] = 6;
    values[valuesById[7] = "PRIMITIVE_DOUBLE"] = 7;
    values[valuesById[8] = "BOOLEAN"] = 8;
    values[valuesById[9] = "BYTE"] = 9;
    values[valuesById[10] = "CHARACTER"] = 10;
    values[valuesById[11] = "SHORT"] = 11;
    values[valuesById[12] = "INTEGER"] = 12;
    values[valuesById[13] = "LONG"] = 13;
    values[valuesById[14] = "FLOAT"] = 14;
    values[valuesById[15] = "DOUBLE"] = 15;
    values[valuesById[25] = "BIG_INTEGER"] = 25;
    values[valuesById[26] = "BIG_DECIMAL"] = 26;
    values[valuesById[16] = "JAVA_SQL_TIME"] = 16;
    values[valuesById[17] = "JAVA_SQL_TIMESTAMP"] = 17;
    values[valuesById[18] = "JAVA_SQL_DATE"] = 18;
    values[valuesById[19] = "JAVA_UTIL_DATE"] = 19;
    values[valuesById[20] = "BYTE_STRING"] = 20;
    values[valuesById[21] = "STRING"] = 21;
    values[valuesById[22] = "NUMBER"] = 22;
    values[valuesById[23] = "OBJECT"] = 23;
    values[valuesById[24] = "NULL"] = 24;
    values[valuesById[27] = "ARRAY"] = 27;
    values[valuesById[28] = "STRUCT"] = 28;
    values[valuesById[29] = "MULTISET"] = 29;
    return values;
})();

export const AvaticaType = $root.AvaticaType = (() => {

    /**
     * Properties of an AvaticaType.
     * @interface IAvaticaType
     * @property {number|null} [id] AvaticaType id
     * @property {string|null} [name] AvaticaType name
     * @property {Rep|null} [rep] AvaticaType rep
     * @property {Array.<IColumnMetaData>|null} [columns] AvaticaType columns
     * @property {IAvaticaType|null} [component] AvaticaType component
     */

    /**
     * Constructs a new AvaticaType.
     * @classdesc Represents an AvaticaType.
     * @implements IAvaticaType
     * @constructor
     * @param {IAvaticaType=} [properties] Properties to set
     */
    function AvaticaType(properties) {
        this.columns = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AvaticaType id.
     * @member {number} id
     * @memberof AvaticaType
     * @instance
     */
    AvaticaType.prototype.id = 0;

    /**
     * AvaticaType name.
     * @member {string} name
     * @memberof AvaticaType
     * @instance
     */
    AvaticaType.prototype.name = "";

    /**
     * AvaticaType rep.
     * @member {Rep} rep
     * @memberof AvaticaType
     * @instance
     */
    AvaticaType.prototype.rep = 0;

    /**
     * AvaticaType columns.
     * @member {Array.<IColumnMetaData>} columns
     * @memberof AvaticaType
     * @instance
     */
    AvaticaType.prototype.columns = $util.emptyArray;

    /**
     * AvaticaType component.
     * @member {IAvaticaType|null|undefined} component
     * @memberof AvaticaType
     * @instance
     */
    AvaticaType.prototype.component = null;

    /**
     * Creates a new AvaticaType instance using the specified properties.
     * @function create
     * @memberof AvaticaType
     * @static
     * @param {IAvaticaType=} [properties] Properties to set
     * @returns {AvaticaType} AvaticaType instance
     */
    AvaticaType.create = function create(properties) {
        return new AvaticaType(properties);
    };

    /**
     * Encodes the specified AvaticaType message. Does not implicitly {@link AvaticaType.verify|verify} messages.
     * @function encode
     * @memberof AvaticaType
     * @static
     * @param {IAvaticaType} message AvaticaType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvaticaType.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
        if (message.rep != null && Object.hasOwnProperty.call(message, "rep"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rep);
        if (message.columns != null && message.columns.length)
            for (let i = 0; i < message.columns.length; ++i)
                $root.ColumnMetaData.encode(message.columns[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.component != null && Object.hasOwnProperty.call(message, "component"))
            $root.AvaticaType.encode(message.component, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified AvaticaType message, length delimited. Does not implicitly {@link AvaticaType.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AvaticaType
     * @static
     * @param {IAvaticaType} message AvaticaType message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvaticaType.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AvaticaType message from the specified reader or buffer.
     * @function decode
     * @memberof AvaticaType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AvaticaType} AvaticaType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvaticaType.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AvaticaType();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.uint32();
                    break;
                }
            case 2: {
                    message.name = reader.string();
                    break;
                }
            case 3: {
                    message.rep = reader.int32();
                    break;
                }
            case 4: {
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.ColumnMetaData.decode(reader, reader.uint32()));
                    break;
                }
            case 5: {
                    message.component = $root.AvaticaType.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AvaticaType message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AvaticaType
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AvaticaType} AvaticaType
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvaticaType.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AvaticaType message.
     * @function verify
     * @memberof AvaticaType
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AvaticaType.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.rep != null && message.hasOwnProperty("rep"))
            switch (message.rep) {
            default:
                return "rep: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 25:
            case 26:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 27:
            case 28:
            case 29:
                break;
            }
        if (message.columns != null && message.hasOwnProperty("columns")) {
            if (!Array.isArray(message.columns))
                return "columns: array expected";
            for (let i = 0; i < message.columns.length; ++i) {
                let error = $root.ColumnMetaData.verify(message.columns[i]);
                if (error)
                    return "columns." + error;
            }
        }
        if (message.component != null && message.hasOwnProperty("component")) {
            let error = $root.AvaticaType.verify(message.component);
            if (error)
                return "component." + error;
        }
        return null;
    };

    /**
     * Creates an AvaticaType message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AvaticaType
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AvaticaType} AvaticaType
     */
    AvaticaType.fromObject = function fromObject(object) {
        if (object instanceof $root.AvaticaType)
            return object;
        let message = new $root.AvaticaType();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.name != null)
            message.name = String(object.name);
        switch (object.rep) {
        default:
            if (typeof object.rep === "number") {
                message.rep = object.rep;
                break;
            }
            break;
        case "PRIMITIVE_BOOLEAN":
        case 0:
            message.rep = 0;
            break;
        case "PRIMITIVE_BYTE":
        case 1:
            message.rep = 1;
            break;
        case "PRIMITIVE_CHAR":
        case 2:
            message.rep = 2;
            break;
        case "PRIMITIVE_SHORT":
        case 3:
            message.rep = 3;
            break;
        case "PRIMITIVE_INT":
        case 4:
            message.rep = 4;
            break;
        case "PRIMITIVE_LONG":
        case 5:
            message.rep = 5;
            break;
        case "PRIMITIVE_FLOAT":
        case 6:
            message.rep = 6;
            break;
        case "PRIMITIVE_DOUBLE":
        case 7:
            message.rep = 7;
            break;
        case "BOOLEAN":
        case 8:
            message.rep = 8;
            break;
        case "BYTE":
        case 9:
            message.rep = 9;
            break;
        case "CHARACTER":
        case 10:
            message.rep = 10;
            break;
        case "SHORT":
        case 11:
            message.rep = 11;
            break;
        case "INTEGER":
        case 12:
            message.rep = 12;
            break;
        case "LONG":
        case 13:
            message.rep = 13;
            break;
        case "FLOAT":
        case 14:
            message.rep = 14;
            break;
        case "DOUBLE":
        case 15:
            message.rep = 15;
            break;
        case "BIG_INTEGER":
        case 25:
            message.rep = 25;
            break;
        case "BIG_DECIMAL":
        case 26:
            message.rep = 26;
            break;
        case "JAVA_SQL_TIME":
        case 16:
            message.rep = 16;
            break;
        case "JAVA_SQL_TIMESTAMP":
        case 17:
            message.rep = 17;
            break;
        case "JAVA_SQL_DATE":
        case 18:
            message.rep = 18;
            break;
        case "JAVA_UTIL_DATE":
        case 19:
            message.rep = 19;
            break;
        case "BYTE_STRING":
        case 20:
            message.rep = 20;
            break;
        case "STRING":
        case 21:
            message.rep = 21;
            break;
        case "NUMBER":
        case 22:
            message.rep = 22;
            break;
        case "OBJECT":
        case 23:
            message.rep = 23;
            break;
        case "NULL":
        case 24:
            message.rep = 24;
            break;
        case "ARRAY":
        case 27:
            message.rep = 27;
            break;
        case "STRUCT":
        case 28:
            message.rep = 28;
            break;
        case "MULTISET":
        case 29:
            message.rep = 29;
            break;
        }
        if (object.columns) {
            if (!Array.isArray(object.columns))
                throw TypeError(".AvaticaType.columns: array expected");
            message.columns = [];
            for (let i = 0; i < object.columns.length; ++i) {
                if (typeof object.columns[i] !== "object")
                    throw TypeError(".AvaticaType.columns: object expected");
                message.columns[i] = $root.ColumnMetaData.fromObject(object.columns[i]);
            }
        }
        if (object.component != null) {
            if (typeof object.component !== "object")
                throw TypeError(".AvaticaType.component: object expected");
            message.component = $root.AvaticaType.fromObject(object.component);
        }
        return message;
    };

    /**
     * Creates a plain object from an AvaticaType message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AvaticaType
     * @static
     * @param {AvaticaType} message AvaticaType
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AvaticaType.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.columns = [];
        if (options.defaults) {
            object.id = 0;
            object.name = "";
            object.rep = options.enums === String ? "PRIMITIVE_BOOLEAN" : 0;
            object.component = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.rep != null && message.hasOwnProperty("rep"))
            object.rep = options.enums === String ? $root.Rep[message.rep] === undefined ? message.rep : $root.Rep[message.rep] : message.rep;
        if (message.columns && message.columns.length) {
            object.columns = [];
            for (let j = 0; j < message.columns.length; ++j)
                object.columns[j] = $root.ColumnMetaData.toObject(message.columns[j], options);
        }
        if (message.component != null && message.hasOwnProperty("component"))
            object.component = $root.AvaticaType.toObject(message.component, options);
        return object;
    };

    /**
     * Converts this AvaticaType to JSON.
     * @function toJSON
     * @memberof AvaticaType
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AvaticaType.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AvaticaType
     * @function getTypeUrl
     * @memberof AvaticaType
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AvaticaType.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AvaticaType";
    };

    return AvaticaType;
})();

export const AvaticaParameter = $root.AvaticaParameter = (() => {

    /**
     * Properties of an AvaticaParameter.
     * @interface IAvaticaParameter
     * @property {boolean|null} [signed] AvaticaParameter signed
     * @property {number|null} [precision] AvaticaParameter precision
     * @property {number|null} [scale] AvaticaParameter scale
     * @property {number|null} [parameterType] AvaticaParameter parameterType
     * @property {string|null} [typeName] AvaticaParameter typeName
     * @property {string|null} [className] AvaticaParameter className
     * @property {string|null} [name] AvaticaParameter name
     */

    /**
     * Constructs a new AvaticaParameter.
     * @classdesc Represents an AvaticaParameter.
     * @implements IAvaticaParameter
     * @constructor
     * @param {IAvaticaParameter=} [properties] Properties to set
     */
    function AvaticaParameter(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * AvaticaParameter signed.
     * @member {boolean} signed
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.signed = false;

    /**
     * AvaticaParameter precision.
     * @member {number} precision
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.precision = 0;

    /**
     * AvaticaParameter scale.
     * @member {number} scale
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.scale = 0;

    /**
     * AvaticaParameter parameterType.
     * @member {number} parameterType
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.parameterType = 0;

    /**
     * AvaticaParameter typeName.
     * @member {string} typeName
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.typeName = "";

    /**
     * AvaticaParameter className.
     * @member {string} className
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.className = "";

    /**
     * AvaticaParameter name.
     * @member {string} name
     * @memberof AvaticaParameter
     * @instance
     */
    AvaticaParameter.prototype.name = "";

    /**
     * Creates a new AvaticaParameter instance using the specified properties.
     * @function create
     * @memberof AvaticaParameter
     * @static
     * @param {IAvaticaParameter=} [properties] Properties to set
     * @returns {AvaticaParameter} AvaticaParameter instance
     */
    AvaticaParameter.create = function create(properties) {
        return new AvaticaParameter(properties);
    };

    /**
     * Encodes the specified AvaticaParameter message. Does not implicitly {@link AvaticaParameter.verify|verify} messages.
     * @function encode
     * @memberof AvaticaParameter
     * @static
     * @param {IAvaticaParameter} message AvaticaParameter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvaticaParameter.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.signed != null && Object.hasOwnProperty.call(message, "signed"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.signed);
        if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.precision);
        if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.scale);
        if (message.parameterType != null && Object.hasOwnProperty.call(message, "parameterType"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.parameterType);
        if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.typeName);
        if (message.className != null && Object.hasOwnProperty.call(message, "className"))
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.className);
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
        return writer;
    };

    /**
     * Encodes the specified AvaticaParameter message, length delimited. Does not implicitly {@link AvaticaParameter.verify|verify} messages.
     * @function encodeDelimited
     * @memberof AvaticaParameter
     * @static
     * @param {IAvaticaParameter} message AvaticaParameter message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    AvaticaParameter.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an AvaticaParameter message from the specified reader or buffer.
     * @function decode
     * @memberof AvaticaParameter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AvaticaParameter} AvaticaParameter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvaticaParameter.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AvaticaParameter();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.signed = reader.bool();
                    break;
                }
            case 2: {
                    message.precision = reader.uint32();
                    break;
                }
            case 3: {
                    message.scale = reader.uint32();
                    break;
                }
            case 4: {
                    message.parameterType = reader.uint32();
                    break;
                }
            case 5: {
                    message.typeName = reader.string();
                    break;
                }
            case 6: {
                    message.className = reader.string();
                    break;
                }
            case 7: {
                    message.name = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an AvaticaParameter message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof AvaticaParameter
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {AvaticaParameter} AvaticaParameter
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AvaticaParameter.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an AvaticaParameter message.
     * @function verify
     * @memberof AvaticaParameter
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    AvaticaParameter.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.signed != null && message.hasOwnProperty("signed"))
            if (typeof message.signed !== "boolean")
                return "signed: boolean expected";
        if (message.precision != null && message.hasOwnProperty("precision"))
            if (!$util.isInteger(message.precision))
                return "precision: integer expected";
        if (message.scale != null && message.hasOwnProperty("scale"))
            if (!$util.isInteger(message.scale))
                return "scale: integer expected";
        if (message.parameterType != null && message.hasOwnProperty("parameterType"))
            if (!$util.isInteger(message.parameterType))
                return "parameterType: integer expected";
        if (message.typeName != null && message.hasOwnProperty("typeName"))
            if (!$util.isString(message.typeName))
                return "typeName: string expected";
        if (message.className != null && message.hasOwnProperty("className"))
            if (!$util.isString(message.className))
                return "className: string expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        return null;
    };

    /**
     * Creates an AvaticaParameter message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof AvaticaParameter
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {AvaticaParameter} AvaticaParameter
     */
    AvaticaParameter.fromObject = function fromObject(object) {
        if (object instanceof $root.AvaticaParameter)
            return object;
        let message = new $root.AvaticaParameter();
        if (object.signed != null)
            message.signed = Boolean(object.signed);
        if (object.precision != null)
            message.precision = object.precision >>> 0;
        if (object.scale != null)
            message.scale = object.scale >>> 0;
        if (object.parameterType != null)
            message.parameterType = object.parameterType >>> 0;
        if (object.typeName != null)
            message.typeName = String(object.typeName);
        if (object.className != null)
            message.className = String(object.className);
        if (object.name != null)
            message.name = String(object.name);
        return message;
    };

    /**
     * Creates a plain object from an AvaticaParameter message. Also converts values to other types if specified.
     * @function toObject
     * @memberof AvaticaParameter
     * @static
     * @param {AvaticaParameter} message AvaticaParameter
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    AvaticaParameter.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.signed = false;
            object.precision = 0;
            object.scale = 0;
            object.parameterType = 0;
            object.typeName = "";
            object.className = "";
            object.name = "";
        }
        if (message.signed != null && message.hasOwnProperty("signed"))
            object.signed = message.signed;
        if (message.precision != null && message.hasOwnProperty("precision"))
            object.precision = message.precision;
        if (message.scale != null && message.hasOwnProperty("scale"))
            object.scale = message.scale;
        if (message.parameterType != null && message.hasOwnProperty("parameterType"))
            object.parameterType = message.parameterType;
        if (message.typeName != null && message.hasOwnProperty("typeName"))
            object.typeName = message.typeName;
        if (message.className != null && message.hasOwnProperty("className"))
            object.className = message.className;
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        return object;
    };

    /**
     * Converts this AvaticaParameter to JSON.
     * @function toJSON
     * @memberof AvaticaParameter
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    AvaticaParameter.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for AvaticaParameter
     * @function getTypeUrl
     * @memberof AvaticaParameter
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    AvaticaParameter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/AvaticaParameter";
    };

    return AvaticaParameter;
})();

export const CursorFactory = $root.CursorFactory = (() => {

    /**
     * Properties of a CursorFactory.
     * @interface ICursorFactory
     * @property {CursorFactory.Style|null} [style] CursorFactory style
     * @property {string|null} [className] CursorFactory className
     * @property {Array.<string>|null} [fieldNames] CursorFactory fieldNames
     */

    /**
     * Constructs a new CursorFactory.
     * @classdesc Represents a CursorFactory.
     * @implements ICursorFactory
     * @constructor
     * @param {ICursorFactory=} [properties] Properties to set
     */
    function CursorFactory(properties) {
        this.fieldNames = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CursorFactory style.
     * @member {CursorFactory.Style} style
     * @memberof CursorFactory
     * @instance
     */
    CursorFactory.prototype.style = 0;

    /**
     * CursorFactory className.
     * @member {string} className
     * @memberof CursorFactory
     * @instance
     */
    CursorFactory.prototype.className = "";

    /**
     * CursorFactory fieldNames.
     * @member {Array.<string>} fieldNames
     * @memberof CursorFactory
     * @instance
     */
    CursorFactory.prototype.fieldNames = $util.emptyArray;

    /**
     * Creates a new CursorFactory instance using the specified properties.
     * @function create
     * @memberof CursorFactory
     * @static
     * @param {ICursorFactory=} [properties] Properties to set
     * @returns {CursorFactory} CursorFactory instance
     */
    CursorFactory.create = function create(properties) {
        return new CursorFactory(properties);
    };

    /**
     * Encodes the specified CursorFactory message. Does not implicitly {@link CursorFactory.verify|verify} messages.
     * @function encode
     * @memberof CursorFactory
     * @static
     * @param {ICursorFactory} message CursorFactory message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CursorFactory.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.style != null && Object.hasOwnProperty.call(message, "style"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
        if (message.className != null && Object.hasOwnProperty.call(message, "className"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.className);
        if (message.fieldNames != null && message.fieldNames.length)
            for (let i = 0; i < message.fieldNames.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.fieldNames[i]);
        return writer;
    };

    /**
     * Encodes the specified CursorFactory message, length delimited. Does not implicitly {@link CursorFactory.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CursorFactory
     * @static
     * @param {ICursorFactory} message CursorFactory message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CursorFactory.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CursorFactory message from the specified reader or buffer.
     * @function decode
     * @memberof CursorFactory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CursorFactory} CursorFactory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CursorFactory.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CursorFactory();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.style = reader.int32();
                    break;
                }
            case 2: {
                    message.className = reader.string();
                    break;
                }
            case 3: {
                    if (!(message.fieldNames && message.fieldNames.length))
                        message.fieldNames = [];
                    message.fieldNames.push(reader.string());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CursorFactory message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CursorFactory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CursorFactory} CursorFactory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CursorFactory.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CursorFactory message.
     * @function verify
     * @memberof CursorFactory
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CursorFactory.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.style != null && message.hasOwnProperty("style"))
            switch (message.style) {
            default:
                return "style: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        if (message.className != null && message.hasOwnProperty("className"))
            if (!$util.isString(message.className))
                return "className: string expected";
        if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
            if (!Array.isArray(message.fieldNames))
                return "fieldNames: array expected";
            for (let i = 0; i < message.fieldNames.length; ++i)
                if (!$util.isString(message.fieldNames[i]))
                    return "fieldNames: string[] expected";
        }
        return null;
    };

    /**
     * Creates a CursorFactory message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CursorFactory
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CursorFactory} CursorFactory
     */
    CursorFactory.fromObject = function fromObject(object) {
        if (object instanceof $root.CursorFactory)
            return object;
        let message = new $root.CursorFactory();
        switch (object.style) {
        default:
            if (typeof object.style === "number") {
                message.style = object.style;
                break;
            }
            break;
        case "OBJECT":
        case 0:
            message.style = 0;
            break;
        case "RECORD":
        case 1:
            message.style = 1;
            break;
        case "RECORD_PROJECTION":
        case 2:
            message.style = 2;
            break;
        case "ARRAY":
        case 3:
            message.style = 3;
            break;
        case "LIST":
        case 4:
            message.style = 4;
            break;
        case "MAP":
        case 5:
            message.style = 5;
            break;
        }
        if (object.className != null)
            message.className = String(object.className);
        if (object.fieldNames) {
            if (!Array.isArray(object.fieldNames))
                throw TypeError(".CursorFactory.fieldNames: array expected");
            message.fieldNames = [];
            for (let i = 0; i < object.fieldNames.length; ++i)
                message.fieldNames[i] = String(object.fieldNames[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a CursorFactory message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CursorFactory
     * @static
     * @param {CursorFactory} message CursorFactory
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CursorFactory.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.fieldNames = [];
        if (options.defaults) {
            object.style = options.enums === String ? "OBJECT" : 0;
            object.className = "";
        }
        if (message.style != null && message.hasOwnProperty("style"))
            object.style = options.enums === String ? $root.CursorFactory.Style[message.style] === undefined ? message.style : $root.CursorFactory.Style[message.style] : message.style;
        if (message.className != null && message.hasOwnProperty("className"))
            object.className = message.className;
        if (message.fieldNames && message.fieldNames.length) {
            object.fieldNames = [];
            for (let j = 0; j < message.fieldNames.length; ++j)
                object.fieldNames[j] = message.fieldNames[j];
        }
        return object;
    };

    /**
     * Converts this CursorFactory to JSON.
     * @function toJSON
     * @memberof CursorFactory
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CursorFactory.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CursorFactory
     * @function getTypeUrl
     * @memberof CursorFactory
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CursorFactory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CursorFactory";
    };

    /**
     * Style enum.
     * @name CursorFactory.Style
     * @enum {number}
     * @property {number} OBJECT=0 OBJECT value
     * @property {number} RECORD=1 RECORD value
     * @property {number} RECORD_PROJECTION=2 RECORD_PROJECTION value
     * @property {number} ARRAY=3 ARRAY value
     * @property {number} LIST=4 LIST value
     * @property {number} MAP=5 MAP value
     */
    CursorFactory.Style = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OBJECT"] = 0;
        values[valuesById[1] = "RECORD"] = 1;
        values[valuesById[2] = "RECORD_PROJECTION"] = 2;
        values[valuesById[3] = "ARRAY"] = 3;
        values[valuesById[4] = "LIST"] = 4;
        values[valuesById[5] = "MAP"] = 5;
        return values;
    })();

    return CursorFactory;
})();

export const Frame = $root.Frame = (() => {

    /**
     * Properties of a Frame.
     * @interface IFrame
     * @property {number|Long|null} [offset] Frame offset
     * @property {boolean|null} [done] Frame done
     * @property {Array.<IRow>|null} [rows] Frame rows
     */

    /**
     * Constructs a new Frame.
     * @classdesc Represents a Frame.
     * @implements IFrame
     * @constructor
     * @param {IFrame=} [properties] Properties to set
     */
    function Frame(properties) {
        this.rows = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Frame offset.
     * @member {number|Long} offset
     * @memberof Frame
     * @instance
     */
    Frame.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Frame done.
     * @member {boolean} done
     * @memberof Frame
     * @instance
     */
    Frame.prototype.done = false;

    /**
     * Frame rows.
     * @member {Array.<IRow>} rows
     * @memberof Frame
     * @instance
     */
    Frame.prototype.rows = $util.emptyArray;

    /**
     * Creates a new Frame instance using the specified properties.
     * @function create
     * @memberof Frame
     * @static
     * @param {IFrame=} [properties] Properties to set
     * @returns {Frame} Frame instance
     */
    Frame.create = function create(properties) {
        return new Frame(properties);
    };

    /**
     * Encodes the specified Frame message. Does not implicitly {@link Frame.verify|verify} messages.
     * @function encode
     * @memberof Frame
     * @static
     * @param {IFrame} message Frame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Frame.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.offset);
        if (message.done != null && Object.hasOwnProperty.call(message, "done"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.done);
        if (message.rows != null && message.rows.length)
            for (let i = 0; i < message.rows.length; ++i)
                $root.Row.encode(message.rows[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Frame message, length delimited. Does not implicitly {@link Frame.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Frame
     * @static
     * @param {IFrame} message Frame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Frame.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Frame message from the specified reader or buffer.
     * @function decode
     * @memberof Frame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Frame} Frame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Frame.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Frame();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.offset = reader.uint64();
                    break;
                }
            case 2: {
                    message.done = reader.bool();
                    break;
                }
            case 3: {
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.Row.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Frame message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Frame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Frame} Frame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Frame.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Frame message.
     * @function verify
     * @memberof Frame
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Frame.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                return "offset: integer|Long expected";
        if (message.done != null && message.hasOwnProperty("done"))
            if (typeof message.done !== "boolean")
                return "done: boolean expected";
        if (message.rows != null && message.hasOwnProperty("rows")) {
            if (!Array.isArray(message.rows))
                return "rows: array expected";
            for (let i = 0; i < message.rows.length; ++i) {
                let error = $root.Row.verify(message.rows[i]);
                if (error)
                    return "rows." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Frame message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Frame
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Frame} Frame
     */
    Frame.fromObject = function fromObject(object) {
        if (object instanceof $root.Frame)
            return object;
        let message = new $root.Frame();
        if (object.offset != null)
            if ($util.Long)
                (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
            else if (typeof object.offset === "string")
                message.offset = parseInt(object.offset, 10);
            else if (typeof object.offset === "number")
                message.offset = object.offset;
            else if (typeof object.offset === "object")
                message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
        if (object.done != null)
            message.done = Boolean(object.done);
        if (object.rows) {
            if (!Array.isArray(object.rows))
                throw TypeError(".Frame.rows: array expected");
            message.rows = [];
            for (let i = 0; i < object.rows.length; ++i) {
                if (typeof object.rows[i] !== "object")
                    throw TypeError(".Frame.rows: object expected");
                message.rows[i] = $root.Row.fromObject(object.rows[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a Frame message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Frame
     * @static
     * @param {Frame} message Frame
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Frame.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.rows = [];
        if (options.defaults) {
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.offset = options.longs === String ? "0" : 0;
            object.done = false;
        }
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (typeof message.offset === "number")
                object.offset = options.longs === String ? String(message.offset) : message.offset;
            else
                object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
        if (message.done != null && message.hasOwnProperty("done"))
            object.done = message.done;
        if (message.rows && message.rows.length) {
            object.rows = [];
            for (let j = 0; j < message.rows.length; ++j)
                object.rows[j] = $root.Row.toObject(message.rows[j], options);
        }
        return object;
    };

    /**
     * Converts this Frame to JSON.
     * @function toJSON
     * @memberof Frame
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Frame.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Frame
     * @function getTypeUrl
     * @memberof Frame
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Frame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Frame";
    };

    return Frame;
})();

export const Row = $root.Row = (() => {

    /**
     * Properties of a Row.
     * @interface IRow
     * @property {Array.<IColumnValue>|null} [value] Row value
     */

    /**
     * Constructs a new Row.
     * @classdesc Represents a Row.
     * @implements IRow
     * @constructor
     * @param {IRow=} [properties] Properties to set
     */
    function Row(properties) {
        this.value = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Row value.
     * @member {Array.<IColumnValue>} value
     * @memberof Row
     * @instance
     */
    Row.prototype.value = $util.emptyArray;

    /**
     * Creates a new Row instance using the specified properties.
     * @function create
     * @memberof Row
     * @static
     * @param {IRow=} [properties] Properties to set
     * @returns {Row} Row instance
     */
    Row.create = function create(properties) {
        return new Row(properties);
    };

    /**
     * Encodes the specified Row message. Does not implicitly {@link Row.verify|verify} messages.
     * @function encode
     * @memberof Row
     * @static
     * @param {IRow} message Row message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Row.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.value != null && message.value.length)
            for (let i = 0; i < message.value.length; ++i)
                $root.ColumnValue.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified Row message, length delimited. Does not implicitly {@link Row.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Row
     * @static
     * @param {IRow} message Row message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Row.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Row message from the specified reader or buffer.
     * @function decode
     * @memberof Row
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Row} Row
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Row.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Row();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push($root.ColumnValue.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a Row message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Row
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Row} Row
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Row.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Row message.
     * @function verify
     * @memberof Row
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Row.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.value != null && message.hasOwnProperty("value")) {
            if (!Array.isArray(message.value))
                return "value: array expected";
            for (let i = 0; i < message.value.length; ++i) {
                let error = $root.ColumnValue.verify(message.value[i]);
                if (error)
                    return "value." + error;
            }
        }
        return null;
    };

    /**
     * Creates a Row message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Row
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Row} Row
     */
    Row.fromObject = function fromObject(object) {
        if (object instanceof $root.Row)
            return object;
        let message = new $root.Row();
        if (object.value) {
            if (!Array.isArray(object.value))
                throw TypeError(".Row.value: array expected");
            message.value = [];
            for (let i = 0; i < object.value.length; ++i) {
                if (typeof object.value[i] !== "object")
                    throw TypeError(".Row.value: object expected");
                message.value[i] = $root.ColumnValue.fromObject(object.value[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a Row message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Row
     * @static
     * @param {Row} message Row
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Row.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.value = [];
        if (message.value && message.value.length) {
            object.value = [];
            for (let j = 0; j < message.value.length; ++j)
                object.value[j] = $root.ColumnValue.toObject(message.value[j], options);
        }
        return object;
    };

    /**
     * Converts this Row to JSON.
     * @function toJSON
     * @memberof Row
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Row.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Row
     * @function getTypeUrl
     * @memberof Row
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Row.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Row";
    };

    return Row;
})();

export const DatabaseProperty = $root.DatabaseProperty = (() => {

    /**
     * Properties of a DatabaseProperty.
     * @interface IDatabaseProperty
     * @property {string|null} [name] DatabaseProperty name
     * @property {Array.<string>|null} [functions] DatabaseProperty functions
     */

    /**
     * Constructs a new DatabaseProperty.
     * @classdesc Represents a DatabaseProperty.
     * @implements IDatabaseProperty
     * @constructor
     * @param {IDatabaseProperty=} [properties] Properties to set
     */
    function DatabaseProperty(properties) {
        this.functions = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DatabaseProperty name.
     * @member {string} name
     * @memberof DatabaseProperty
     * @instance
     */
    DatabaseProperty.prototype.name = "";

    /**
     * DatabaseProperty functions.
     * @member {Array.<string>} functions
     * @memberof DatabaseProperty
     * @instance
     */
    DatabaseProperty.prototype.functions = $util.emptyArray;

    /**
     * Creates a new DatabaseProperty instance using the specified properties.
     * @function create
     * @memberof DatabaseProperty
     * @static
     * @param {IDatabaseProperty=} [properties] Properties to set
     * @returns {DatabaseProperty} DatabaseProperty instance
     */
    DatabaseProperty.create = function create(properties) {
        return new DatabaseProperty(properties);
    };

    /**
     * Encodes the specified DatabaseProperty message. Does not implicitly {@link DatabaseProperty.verify|verify} messages.
     * @function encode
     * @memberof DatabaseProperty
     * @static
     * @param {IDatabaseProperty} message DatabaseProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabaseProperty.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.functions != null && message.functions.length)
            for (let i = 0; i < message.functions.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.functions[i]);
        return writer;
    };

    /**
     * Encodes the specified DatabaseProperty message, length delimited. Does not implicitly {@link DatabaseProperty.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DatabaseProperty
     * @static
     * @param {IDatabaseProperty} message DatabaseProperty message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabaseProperty.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DatabaseProperty message from the specified reader or buffer.
     * @function decode
     * @memberof DatabaseProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DatabaseProperty} DatabaseProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabaseProperty.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DatabaseProperty();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    if (!(message.functions && message.functions.length))
                        message.functions = [];
                    message.functions.push(reader.string());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DatabaseProperty message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DatabaseProperty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DatabaseProperty} DatabaseProperty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabaseProperty.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DatabaseProperty message.
     * @function verify
     * @memberof DatabaseProperty
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DatabaseProperty.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.functions != null && message.hasOwnProperty("functions")) {
            if (!Array.isArray(message.functions))
                return "functions: array expected";
            for (let i = 0; i < message.functions.length; ++i)
                if (!$util.isString(message.functions[i]))
                    return "functions: string[] expected";
        }
        return null;
    };

    /**
     * Creates a DatabaseProperty message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DatabaseProperty
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DatabaseProperty} DatabaseProperty
     */
    DatabaseProperty.fromObject = function fromObject(object) {
        if (object instanceof $root.DatabaseProperty)
            return object;
        let message = new $root.DatabaseProperty();
        if (object.name != null)
            message.name = String(object.name);
        if (object.functions) {
            if (!Array.isArray(object.functions))
                throw TypeError(".DatabaseProperty.functions: array expected");
            message.functions = [];
            for (let i = 0; i < object.functions.length; ++i)
                message.functions[i] = String(object.functions[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a DatabaseProperty message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DatabaseProperty
     * @static
     * @param {DatabaseProperty} message DatabaseProperty
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DatabaseProperty.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.functions = [];
        if (options.defaults)
            object.name = "";
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.functions && message.functions.length) {
            object.functions = [];
            for (let j = 0; j < message.functions.length; ++j)
                object.functions[j] = message.functions[j];
        }
        return object;
    };

    /**
     * Converts this DatabaseProperty to JSON.
     * @function toJSON
     * @memberof DatabaseProperty
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DatabaseProperty.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DatabaseProperty
     * @function getTypeUrl
     * @memberof DatabaseProperty
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DatabaseProperty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DatabaseProperty";
    };

    return DatabaseProperty;
})();

export const WireMessage = $root.WireMessage = (() => {

    /**
     * Properties of a WireMessage.
     * @interface IWireMessage
     * @property {string|null} [name] WireMessage name
     * @property {Uint8Array|null} [wrappedMessage] WireMessage wrappedMessage
     */

    /**
     * Constructs a new WireMessage.
     * @classdesc Represents a WireMessage.
     * @implements IWireMessage
     * @constructor
     * @param {IWireMessage=} [properties] Properties to set
     */
    function WireMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * WireMessage name.
     * @member {string} name
     * @memberof WireMessage
     * @instance
     */
    WireMessage.prototype.name = "";

    /**
     * WireMessage wrappedMessage.
     * @member {Uint8Array} wrappedMessage
     * @memberof WireMessage
     * @instance
     */
    WireMessage.prototype.wrappedMessage = $util.newBuffer([]);

    /**
     * Creates a new WireMessage instance using the specified properties.
     * @function create
     * @memberof WireMessage
     * @static
     * @param {IWireMessage=} [properties] Properties to set
     * @returns {WireMessage} WireMessage instance
     */
    WireMessage.create = function create(properties) {
        return new WireMessage(properties);
    };

    /**
     * Encodes the specified WireMessage message. Does not implicitly {@link WireMessage.verify|verify} messages.
     * @function encode
     * @memberof WireMessage
     * @static
     * @param {IWireMessage} message WireMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WireMessage.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        if (message.wrappedMessage != null && Object.hasOwnProperty.call(message, "wrappedMessage"))
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.wrappedMessage);
        return writer;
    };

    /**
     * Encodes the specified WireMessage message, length delimited. Does not implicitly {@link WireMessage.verify|verify} messages.
     * @function encodeDelimited
     * @memberof WireMessage
     * @static
     * @param {IWireMessage} message WireMessage message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    WireMessage.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a WireMessage message from the specified reader or buffer.
     * @function decode
     * @memberof WireMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WireMessage} WireMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WireMessage.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WireMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.wrappedMessage = reader.bytes();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a WireMessage message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof WireMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {WireMessage} WireMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WireMessage.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a WireMessage message.
     * @function verify
     * @memberof WireMessage
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    WireMessage.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.name != null && message.hasOwnProperty("name"))
            if (!$util.isString(message.name))
                return "name: string expected";
        if (message.wrappedMessage != null && message.hasOwnProperty("wrappedMessage"))
            if (!(message.wrappedMessage && typeof message.wrappedMessage.length === "number" || $util.isString(message.wrappedMessage)))
                return "wrappedMessage: buffer expected";
        return null;
    };

    /**
     * Creates a WireMessage message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof WireMessage
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {WireMessage} WireMessage
     */
    WireMessage.fromObject = function fromObject(object) {
        if (object instanceof $root.WireMessage)
            return object;
        let message = new $root.WireMessage();
        if (object.name != null)
            message.name = String(object.name);
        if (object.wrappedMessage != null)
            if (typeof object.wrappedMessage === "string")
                $util.base64.decode(object.wrappedMessage, message.wrappedMessage = $util.newBuffer($util.base64.length(object.wrappedMessage)), 0);
            else if (object.wrappedMessage.length >= 0)
                message.wrappedMessage = object.wrappedMessage;
        return message;
    };

    /**
     * Creates a plain object from a WireMessage message. Also converts values to other types if specified.
     * @function toObject
     * @memberof WireMessage
     * @static
     * @param {WireMessage} message WireMessage
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    WireMessage.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            if (options.bytes === String)
                object.wrappedMessage = "";
            else {
                object.wrappedMessage = [];
                if (options.bytes !== Array)
                    object.wrappedMessage = $util.newBuffer(object.wrappedMessage);
            }
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.wrappedMessage != null && message.hasOwnProperty("wrappedMessage"))
            object.wrappedMessage = options.bytes === String ? $util.base64.encode(message.wrappedMessage, 0, message.wrappedMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.wrappedMessage) : message.wrappedMessage;
        return object;
    };

    /**
     * Converts this WireMessage to JSON.
     * @function toJSON
     * @memberof WireMessage
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    WireMessage.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for WireMessage
     * @function getTypeUrl
     * @memberof WireMessage
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    WireMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/WireMessage";
    };

    return WireMessage;
})();

export const ColumnValue = $root.ColumnValue = (() => {

    /**
     * Properties of a ColumnValue.
     * @interface IColumnValue
     * @property {Array.<ITypedValue>|null} [value] ColumnValue value
     * @property {Array.<ITypedValue>|null} [arrayValue] ColumnValue arrayValue
     * @property {boolean|null} [hasArrayValue] ColumnValue hasArrayValue
     * @property {ITypedValue|null} [scalarValue] ColumnValue scalarValue
     */

    /**
     * Constructs a new ColumnValue.
     * @classdesc Represents a ColumnValue.
     * @implements IColumnValue
     * @constructor
     * @param {IColumnValue=} [properties] Properties to set
     */
    function ColumnValue(properties) {
        this.value = [];
        this.arrayValue = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ColumnValue value.
     * @member {Array.<ITypedValue>} value
     * @memberof ColumnValue
     * @instance
     */
    ColumnValue.prototype.value = $util.emptyArray;

    /**
     * ColumnValue arrayValue.
     * @member {Array.<ITypedValue>} arrayValue
     * @memberof ColumnValue
     * @instance
     */
    ColumnValue.prototype.arrayValue = $util.emptyArray;

    /**
     * ColumnValue hasArrayValue.
     * @member {boolean} hasArrayValue
     * @memberof ColumnValue
     * @instance
     */
    ColumnValue.prototype.hasArrayValue = false;

    /**
     * ColumnValue scalarValue.
     * @member {ITypedValue|null|undefined} scalarValue
     * @memberof ColumnValue
     * @instance
     */
    ColumnValue.prototype.scalarValue = null;

    /**
     * Creates a new ColumnValue instance using the specified properties.
     * @function create
     * @memberof ColumnValue
     * @static
     * @param {IColumnValue=} [properties] Properties to set
     * @returns {ColumnValue} ColumnValue instance
     */
    ColumnValue.create = function create(properties) {
        return new ColumnValue(properties);
    };

    /**
     * Encodes the specified ColumnValue message. Does not implicitly {@link ColumnValue.verify|verify} messages.
     * @function encode
     * @memberof ColumnValue
     * @static
     * @param {IColumnValue} message ColumnValue message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnValue.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.value != null && message.value.length)
            for (let i = 0; i < message.value.length; ++i)
                $root.TypedValue.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.arrayValue != null && message.arrayValue.length)
            for (let i = 0; i < message.arrayValue.length; ++i)
                $root.TypedValue.encode(message.arrayValue[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.hasArrayValue != null && Object.hasOwnProperty.call(message, "hasArrayValue"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasArrayValue);
        if (message.scalarValue != null && Object.hasOwnProperty.call(message, "scalarValue"))
            $root.TypedValue.encode(message.scalarValue, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ColumnValue message, length delimited. Does not implicitly {@link ColumnValue.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ColumnValue
     * @static
     * @param {IColumnValue} message ColumnValue message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnValue.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ColumnValue message from the specified reader or buffer.
     * @function decode
     * @memberof ColumnValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ColumnValue} ColumnValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnValue.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ColumnValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.value && message.value.length))
                        message.value = [];
                    message.value.push($root.TypedValue.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    if (!(message.arrayValue && message.arrayValue.length))
                        message.arrayValue = [];
                    message.arrayValue.push($root.TypedValue.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    message.hasArrayValue = reader.bool();
                    break;
                }
            case 4: {
                    message.scalarValue = $root.TypedValue.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ColumnValue message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ColumnValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ColumnValue} ColumnValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnValue.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ColumnValue message.
     * @function verify
     * @memberof ColumnValue
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ColumnValue.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.value != null && message.hasOwnProperty("value")) {
            if (!Array.isArray(message.value))
                return "value: array expected";
            for (let i = 0; i < message.value.length; ++i) {
                let error = $root.TypedValue.verify(message.value[i]);
                if (error)
                    return "value." + error;
            }
        }
        if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
            if (!Array.isArray(message.arrayValue))
                return "arrayValue: array expected";
            for (let i = 0; i < message.arrayValue.length; ++i) {
                let error = $root.TypedValue.verify(message.arrayValue[i]);
                if (error)
                    return "arrayValue." + error;
            }
        }
        if (message.hasArrayValue != null && message.hasOwnProperty("hasArrayValue"))
            if (typeof message.hasArrayValue !== "boolean")
                return "hasArrayValue: boolean expected";
        if (message.scalarValue != null && message.hasOwnProperty("scalarValue")) {
            let error = $root.TypedValue.verify(message.scalarValue);
            if (error)
                return "scalarValue." + error;
        }
        return null;
    };

    /**
     * Creates a ColumnValue message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ColumnValue
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ColumnValue} ColumnValue
     */
    ColumnValue.fromObject = function fromObject(object) {
        if (object instanceof $root.ColumnValue)
            return object;
        let message = new $root.ColumnValue();
        if (object.value) {
            if (!Array.isArray(object.value))
                throw TypeError(".ColumnValue.value: array expected");
            message.value = [];
            for (let i = 0; i < object.value.length; ++i) {
                if (typeof object.value[i] !== "object")
                    throw TypeError(".ColumnValue.value: object expected");
                message.value[i] = $root.TypedValue.fromObject(object.value[i]);
            }
        }
        if (object.arrayValue) {
            if (!Array.isArray(object.arrayValue))
                throw TypeError(".ColumnValue.arrayValue: array expected");
            message.arrayValue = [];
            for (let i = 0; i < object.arrayValue.length; ++i) {
                if (typeof object.arrayValue[i] !== "object")
                    throw TypeError(".ColumnValue.arrayValue: object expected");
                message.arrayValue[i] = $root.TypedValue.fromObject(object.arrayValue[i]);
            }
        }
        if (object.hasArrayValue != null)
            message.hasArrayValue = Boolean(object.hasArrayValue);
        if (object.scalarValue != null) {
            if (typeof object.scalarValue !== "object")
                throw TypeError(".ColumnValue.scalarValue: object expected");
            message.scalarValue = $root.TypedValue.fromObject(object.scalarValue);
        }
        return message;
    };

    /**
     * Creates a plain object from a ColumnValue message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ColumnValue
     * @static
     * @param {ColumnValue} message ColumnValue
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ColumnValue.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.value = [];
            object.arrayValue = [];
        }
        if (options.defaults) {
            object.hasArrayValue = false;
            object.scalarValue = null;
        }
        if (message.value && message.value.length) {
            object.value = [];
            for (let j = 0; j < message.value.length; ++j)
                object.value[j] = $root.TypedValue.toObject(message.value[j], options);
        }
        if (message.arrayValue && message.arrayValue.length) {
            object.arrayValue = [];
            for (let j = 0; j < message.arrayValue.length; ++j)
                object.arrayValue[j] = $root.TypedValue.toObject(message.arrayValue[j], options);
        }
        if (message.hasArrayValue != null && message.hasOwnProperty("hasArrayValue"))
            object.hasArrayValue = message.hasArrayValue;
        if (message.scalarValue != null && message.hasOwnProperty("scalarValue"))
            object.scalarValue = $root.TypedValue.toObject(message.scalarValue, options);
        return object;
    };

    /**
     * Converts this ColumnValue to JSON.
     * @function toJSON
     * @memberof ColumnValue
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ColumnValue.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ColumnValue
     * @function getTypeUrl
     * @memberof ColumnValue
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ColumnValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ColumnValue";
    };

    return ColumnValue;
})();

export const TypedValue = $root.TypedValue = (() => {

    /**
     * Properties of a TypedValue.
     * @interface ITypedValue
     * @property {Rep|null} [type] TypedValue type
     * @property {boolean|null} [boolValue] TypedValue boolValue
     * @property {string|null} [stringValue] TypedValue stringValue
     * @property {number|Long|null} [numberValue] TypedValue numberValue
     * @property {Uint8Array|null} [bytesValue] TypedValue bytesValue
     * @property {number|null} [doubleValue] TypedValue doubleValue
     * @property {boolean|null} ["null"] TypedValue null
     * @property {Array.<ITypedValue>|null} [arrayValue] TypedValue arrayValue
     * @property {Rep|null} [componentType] TypedValue componentType
     * @property {boolean|null} [implicitlyNull] TypedValue implicitlyNull
     */

    /**
     * Constructs a new TypedValue.
     * @classdesc Represents a TypedValue.
     * @implements ITypedValue
     * @constructor
     * @param {ITypedValue=} [properties] Properties to set
     */
    function TypedValue(properties) {
        this.arrayValue = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TypedValue type.
     * @member {Rep} type
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.type = 0;

    /**
     * TypedValue boolValue.
     * @member {boolean} boolValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.boolValue = false;

    /**
     * TypedValue stringValue.
     * @member {string} stringValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.stringValue = "";

    /**
     * TypedValue numberValue.
     * @member {number|Long} numberValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.numberValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * TypedValue bytesValue.
     * @member {Uint8Array} bytesValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.bytesValue = $util.newBuffer([]);

    /**
     * TypedValue doubleValue.
     * @member {number} doubleValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.doubleValue = 0;

    /**
     * TypedValue null.
     * @member {boolean} null
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype["null"] = false;

    /**
     * TypedValue arrayValue.
     * @member {Array.<ITypedValue>} arrayValue
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.arrayValue = $util.emptyArray;

    /**
     * TypedValue componentType.
     * @member {Rep} componentType
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.componentType = 0;

    /**
     * TypedValue implicitlyNull.
     * @member {boolean} implicitlyNull
     * @memberof TypedValue
     * @instance
     */
    TypedValue.prototype.implicitlyNull = false;

    /**
     * Creates a new TypedValue instance using the specified properties.
     * @function create
     * @memberof TypedValue
     * @static
     * @param {ITypedValue=} [properties] Properties to set
     * @returns {TypedValue} TypedValue instance
     */
    TypedValue.create = function create(properties) {
        return new TypedValue(properties);
    };

    /**
     * Encodes the specified TypedValue message. Does not implicitly {@link TypedValue.verify|verify} messages.
     * @function encode
     * @memberof TypedValue
     * @static
     * @param {ITypedValue} message TypedValue message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypedValue.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.boolValue);
        if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
        if (message.numberValue != null && Object.hasOwnProperty.call(message, "numberValue"))
            writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.numberValue);
        if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.bytesValue);
        if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
        if (message["null"] != null && Object.hasOwnProperty.call(message, "null"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message["null"]);
        if (message.arrayValue != null && message.arrayValue.length)
            for (let i = 0; i < message.arrayValue.length; ++i)
                $root.TypedValue.encode(message.arrayValue[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
        if (message.componentType != null && Object.hasOwnProperty.call(message, "componentType"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.componentType);
        if (message.implicitlyNull != null && Object.hasOwnProperty.call(message, "implicitlyNull"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.implicitlyNull);
        return writer;
    };

    /**
     * Encodes the specified TypedValue message, length delimited. Does not implicitly {@link TypedValue.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TypedValue
     * @static
     * @param {ITypedValue} message TypedValue message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypedValue.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TypedValue message from the specified reader or buffer.
     * @function decode
     * @memberof TypedValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TypedValue} TypedValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypedValue.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TypedValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.type = reader.int32();
                    break;
                }
            case 2: {
                    message.boolValue = reader.bool();
                    break;
                }
            case 3: {
                    message.stringValue = reader.string();
                    break;
                }
            case 4: {
                    message.numberValue = reader.sint64();
                    break;
                }
            case 5: {
                    message.bytesValue = reader.bytes();
                    break;
                }
            case 6: {
                    message.doubleValue = reader.double();
                    break;
                }
            case 7: {
                    message["null"] = reader.bool();
                    break;
                }
            case 8: {
                    if (!(message.arrayValue && message.arrayValue.length))
                        message.arrayValue = [];
                    message.arrayValue.push($root.TypedValue.decode(reader, reader.uint32()));
                    break;
                }
            case 9: {
                    message.componentType = reader.int32();
                    break;
                }
            case 10: {
                    message.implicitlyNull = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TypedValue message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TypedValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TypedValue} TypedValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypedValue.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TypedValue message.
     * @function verify
     * @memberof TypedValue
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TypedValue.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 25:
            case 26:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 27:
            case 28:
            case 29:
                break;
            }
        if (message.boolValue != null && message.hasOwnProperty("boolValue"))
            if (typeof message.boolValue !== "boolean")
                return "boolValue: boolean expected";
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            if (!$util.isString(message.stringValue))
                return "stringValue: string expected";
        if (message.numberValue != null && message.hasOwnProperty("numberValue"))
            if (!$util.isInteger(message.numberValue) && !(message.numberValue && $util.isInteger(message.numberValue.low) && $util.isInteger(message.numberValue.high)))
                return "numberValue: integer|Long expected";
        if (message.bytesValue != null && message.hasOwnProperty("bytesValue"))
            if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                return "bytesValue: buffer expected";
        if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
            if (typeof message.doubleValue !== "number")
                return "doubleValue: number expected";
        if (message["null"] != null && message.hasOwnProperty("null"))
            if (typeof message["null"] !== "boolean")
                return "null: boolean expected";
        if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
            if (!Array.isArray(message.arrayValue))
                return "arrayValue: array expected";
            for (let i = 0; i < message.arrayValue.length; ++i) {
                let error = $root.TypedValue.verify(message.arrayValue[i]);
                if (error)
                    return "arrayValue." + error;
            }
        }
        if (message.componentType != null && message.hasOwnProperty("componentType"))
            switch (message.componentType) {
            default:
                return "componentType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 25:
            case 26:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 27:
            case 28:
            case 29:
                break;
            }
        if (message.implicitlyNull != null && message.hasOwnProperty("implicitlyNull"))
            if (typeof message.implicitlyNull !== "boolean")
                return "implicitlyNull: boolean expected";
        return null;
    };

    /**
     * Creates a TypedValue message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TypedValue
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TypedValue} TypedValue
     */
    TypedValue.fromObject = function fromObject(object) {
        if (object instanceof $root.TypedValue)
            return object;
        let message = new $root.TypedValue();
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "PRIMITIVE_BOOLEAN":
        case 0:
            message.type = 0;
            break;
        case "PRIMITIVE_BYTE":
        case 1:
            message.type = 1;
            break;
        case "PRIMITIVE_CHAR":
        case 2:
            message.type = 2;
            break;
        case "PRIMITIVE_SHORT":
        case 3:
            message.type = 3;
            break;
        case "PRIMITIVE_INT":
        case 4:
            message.type = 4;
            break;
        case "PRIMITIVE_LONG":
        case 5:
            message.type = 5;
            break;
        case "PRIMITIVE_FLOAT":
        case 6:
            message.type = 6;
            break;
        case "PRIMITIVE_DOUBLE":
        case 7:
            message.type = 7;
            break;
        case "BOOLEAN":
        case 8:
            message.type = 8;
            break;
        case "BYTE":
        case 9:
            message.type = 9;
            break;
        case "CHARACTER":
        case 10:
            message.type = 10;
            break;
        case "SHORT":
        case 11:
            message.type = 11;
            break;
        case "INTEGER":
        case 12:
            message.type = 12;
            break;
        case "LONG":
        case 13:
            message.type = 13;
            break;
        case "FLOAT":
        case 14:
            message.type = 14;
            break;
        case "DOUBLE":
        case 15:
            message.type = 15;
            break;
        case "BIG_INTEGER":
        case 25:
            message.type = 25;
            break;
        case "BIG_DECIMAL":
        case 26:
            message.type = 26;
            break;
        case "JAVA_SQL_TIME":
        case 16:
            message.type = 16;
            break;
        case "JAVA_SQL_TIMESTAMP":
        case 17:
            message.type = 17;
            break;
        case "JAVA_SQL_DATE":
        case 18:
            message.type = 18;
            break;
        case "JAVA_UTIL_DATE":
        case 19:
            message.type = 19;
            break;
        case "BYTE_STRING":
        case 20:
            message.type = 20;
            break;
        case "STRING":
        case 21:
            message.type = 21;
            break;
        case "NUMBER":
        case 22:
            message.type = 22;
            break;
        case "OBJECT":
        case 23:
            message.type = 23;
            break;
        case "NULL":
        case 24:
            message.type = 24;
            break;
        case "ARRAY":
        case 27:
            message.type = 27;
            break;
        case "STRUCT":
        case 28:
            message.type = 28;
            break;
        case "MULTISET":
        case 29:
            message.type = 29;
            break;
        }
        if (object.boolValue != null)
            message.boolValue = Boolean(object.boolValue);
        if (object.stringValue != null)
            message.stringValue = String(object.stringValue);
        if (object.numberValue != null)
            if ($util.Long)
                (message.numberValue = $util.Long.fromValue(object.numberValue)).unsigned = false;
            else if (typeof object.numberValue === "string")
                message.numberValue = parseInt(object.numberValue, 10);
            else if (typeof object.numberValue === "number")
                message.numberValue = object.numberValue;
            else if (typeof object.numberValue === "object")
                message.numberValue = new $util.LongBits(object.numberValue.low >>> 0, object.numberValue.high >>> 0).toNumber();
        if (object.bytesValue != null)
            if (typeof object.bytesValue === "string")
                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
            else if (object.bytesValue.length >= 0)
                message.bytesValue = object.bytesValue;
        if (object.doubleValue != null)
            message.doubleValue = Number(object.doubleValue);
        if (object["null"] != null)
            message["null"] = Boolean(object["null"]);
        if (object.arrayValue) {
            if (!Array.isArray(object.arrayValue))
                throw TypeError(".TypedValue.arrayValue: array expected");
            message.arrayValue = [];
            for (let i = 0; i < object.arrayValue.length; ++i) {
                if (typeof object.arrayValue[i] !== "object")
                    throw TypeError(".TypedValue.arrayValue: object expected");
                message.arrayValue[i] = $root.TypedValue.fromObject(object.arrayValue[i]);
            }
        }
        switch (object.componentType) {
        default:
            if (typeof object.componentType === "number") {
                message.componentType = object.componentType;
                break;
            }
            break;
        case "PRIMITIVE_BOOLEAN":
        case 0:
            message.componentType = 0;
            break;
        case "PRIMITIVE_BYTE":
        case 1:
            message.componentType = 1;
            break;
        case "PRIMITIVE_CHAR":
        case 2:
            message.componentType = 2;
            break;
        case "PRIMITIVE_SHORT":
        case 3:
            message.componentType = 3;
            break;
        case "PRIMITIVE_INT":
        case 4:
            message.componentType = 4;
            break;
        case "PRIMITIVE_LONG":
        case 5:
            message.componentType = 5;
            break;
        case "PRIMITIVE_FLOAT":
        case 6:
            message.componentType = 6;
            break;
        case "PRIMITIVE_DOUBLE":
        case 7:
            message.componentType = 7;
            break;
        case "BOOLEAN":
        case 8:
            message.componentType = 8;
            break;
        case "BYTE":
        case 9:
            message.componentType = 9;
            break;
        case "CHARACTER":
        case 10:
            message.componentType = 10;
            break;
        case "SHORT":
        case 11:
            message.componentType = 11;
            break;
        case "INTEGER":
        case 12:
            message.componentType = 12;
            break;
        case "LONG":
        case 13:
            message.componentType = 13;
            break;
        case "FLOAT":
        case 14:
            message.componentType = 14;
            break;
        case "DOUBLE":
        case 15:
            message.componentType = 15;
            break;
        case "BIG_INTEGER":
        case 25:
            message.componentType = 25;
            break;
        case "BIG_DECIMAL":
        case 26:
            message.componentType = 26;
            break;
        case "JAVA_SQL_TIME":
        case 16:
            message.componentType = 16;
            break;
        case "JAVA_SQL_TIMESTAMP":
        case 17:
            message.componentType = 17;
            break;
        case "JAVA_SQL_DATE":
        case 18:
            message.componentType = 18;
            break;
        case "JAVA_UTIL_DATE":
        case 19:
            message.componentType = 19;
            break;
        case "BYTE_STRING":
        case 20:
            message.componentType = 20;
            break;
        case "STRING":
        case 21:
            message.componentType = 21;
            break;
        case "NUMBER":
        case 22:
            message.componentType = 22;
            break;
        case "OBJECT":
        case 23:
            message.componentType = 23;
            break;
        case "NULL":
        case 24:
            message.componentType = 24;
            break;
        case "ARRAY":
        case 27:
            message.componentType = 27;
            break;
        case "STRUCT":
        case 28:
            message.componentType = 28;
            break;
        case "MULTISET":
        case 29:
            message.componentType = 29;
            break;
        }
        if (object.implicitlyNull != null)
            message.implicitlyNull = Boolean(object.implicitlyNull);
        return message;
    };

    /**
     * Creates a plain object from a TypedValue message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TypedValue
     * @static
     * @param {TypedValue} message TypedValue
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TypedValue.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.arrayValue = [];
        if (options.defaults) {
            object.type = options.enums === String ? "PRIMITIVE_BOOLEAN" : 0;
            object.boolValue = false;
            object.stringValue = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.numberValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.numberValue = options.longs === String ? "0" : 0;
            if (options.bytes === String)
                object.bytesValue = "";
            else {
                object.bytesValue = [];
                if (options.bytes !== Array)
                    object.bytesValue = $util.newBuffer(object.bytesValue);
            }
            object.doubleValue = 0;
            object["null"] = false;
            object.componentType = options.enums === String ? "PRIMITIVE_BOOLEAN" : 0;
            object.implicitlyNull = false;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.Rep[message.type] === undefined ? message.type : $root.Rep[message.type] : message.type;
        if (message.boolValue != null && message.hasOwnProperty("boolValue"))
            object.boolValue = message.boolValue;
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            object.stringValue = message.stringValue;
        if (message.numberValue != null && message.hasOwnProperty("numberValue"))
            if (typeof message.numberValue === "number")
                object.numberValue = options.longs === String ? String(message.numberValue) : message.numberValue;
            else
                object.numberValue = options.longs === String ? $util.Long.prototype.toString.call(message.numberValue) : options.longs === Number ? new $util.LongBits(message.numberValue.low >>> 0, message.numberValue.high >>> 0).toNumber() : message.numberValue;
        if (message.bytesValue != null && message.hasOwnProperty("bytesValue"))
            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
        if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
        if (message["null"] != null && message.hasOwnProperty("null"))
            object["null"] = message["null"];
        if (message.arrayValue && message.arrayValue.length) {
            object.arrayValue = [];
            for (let j = 0; j < message.arrayValue.length; ++j)
                object.arrayValue[j] = $root.TypedValue.toObject(message.arrayValue[j], options);
        }
        if (message.componentType != null && message.hasOwnProperty("componentType"))
            object.componentType = options.enums === String ? $root.Rep[message.componentType] === undefined ? message.componentType : $root.Rep[message.componentType] : message.componentType;
        if (message.implicitlyNull != null && message.hasOwnProperty("implicitlyNull"))
            object.implicitlyNull = message.implicitlyNull;
        return object;
    };

    /**
     * Converts this TypedValue to JSON.
     * @function toJSON
     * @memberof TypedValue
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TypedValue.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TypedValue
     * @function getTypeUrl
     * @memberof TypedValue
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TypedValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TypedValue";
    };

    return TypedValue;
})();

/**
 * Severity enum.
 * @enum {number}
 * @property {number} UNKNOWN_SEVERITY=0 UNKNOWN_SEVERITY value
 * @property {number} FATAL_SEVERITY=1 FATAL_SEVERITY value
 * @property {number} ERROR_SEVERITY=2 ERROR_SEVERITY value
 * @property {number} WARNING_SEVERITY=3 WARNING_SEVERITY value
 */
export const Severity = $root.Severity = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "UNKNOWN_SEVERITY"] = 0;
    values[valuesById[1] = "FATAL_SEVERITY"] = 1;
    values[valuesById[2] = "ERROR_SEVERITY"] = 2;
    values[valuesById[3] = "WARNING_SEVERITY"] = 3;
    return values;
})();

/**
 * MetaDataOperation enum.
 * @enum {number}
 * @property {number} GET_ATTRIBUTES=0 GET_ATTRIBUTES value
 * @property {number} GET_BEST_ROW_IDENTIFIER=1 GET_BEST_ROW_IDENTIFIER value
 * @property {number} GET_CATALOGS=2 GET_CATALOGS value
 * @property {number} GET_CLIENT_INFO_PROPERTIES=3 GET_CLIENT_INFO_PROPERTIES value
 * @property {number} GET_COLUMN_PRIVILEGES=4 GET_COLUMN_PRIVILEGES value
 * @property {number} GET_COLUMNS=5 GET_COLUMNS value
 * @property {number} GET_CROSS_REFERENCE=6 GET_CROSS_REFERENCE value
 * @property {number} GET_EXPORTED_KEYS=7 GET_EXPORTED_KEYS value
 * @property {number} GET_FUNCTION_COLUMNS=8 GET_FUNCTION_COLUMNS value
 * @property {number} GET_FUNCTIONS=9 GET_FUNCTIONS value
 * @property {number} GET_IMPORTED_KEYS=10 GET_IMPORTED_KEYS value
 * @property {number} GET_INDEX_INFO=11 GET_INDEX_INFO value
 * @property {number} GET_PRIMARY_KEYS=12 GET_PRIMARY_KEYS value
 * @property {number} GET_PROCEDURE_COLUMNS=13 GET_PROCEDURE_COLUMNS value
 * @property {number} GET_PROCEDURES=14 GET_PROCEDURES value
 * @property {number} GET_PSEUDO_COLUMNS=15 GET_PSEUDO_COLUMNS value
 * @property {number} GET_SCHEMAS=16 GET_SCHEMAS value
 * @property {number} GET_SCHEMAS_WITH_ARGS=17 GET_SCHEMAS_WITH_ARGS value
 * @property {number} GET_SUPER_TABLES=18 GET_SUPER_TABLES value
 * @property {number} GET_SUPER_TYPES=19 GET_SUPER_TYPES value
 * @property {number} GET_TABLE_PRIVILEGES=20 GET_TABLE_PRIVILEGES value
 * @property {number} GET_TABLES=21 GET_TABLES value
 * @property {number} GET_TABLE_TYPES=22 GET_TABLE_TYPES value
 * @property {number} GET_TYPE_INFO=23 GET_TYPE_INFO value
 * @property {number} GET_UDTS=24 GET_UDTS value
 * @property {number} GET_VERSION_COLUMNS=25 GET_VERSION_COLUMNS value
 */
export const MetaDataOperation = $root.MetaDataOperation = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "GET_ATTRIBUTES"] = 0;
    values[valuesById[1] = "GET_BEST_ROW_IDENTIFIER"] = 1;
    values[valuesById[2] = "GET_CATALOGS"] = 2;
    values[valuesById[3] = "GET_CLIENT_INFO_PROPERTIES"] = 3;
    values[valuesById[4] = "GET_COLUMN_PRIVILEGES"] = 4;
    values[valuesById[5] = "GET_COLUMNS"] = 5;
    values[valuesById[6] = "GET_CROSS_REFERENCE"] = 6;
    values[valuesById[7] = "GET_EXPORTED_KEYS"] = 7;
    values[valuesById[8] = "GET_FUNCTION_COLUMNS"] = 8;
    values[valuesById[9] = "GET_FUNCTIONS"] = 9;
    values[valuesById[10] = "GET_IMPORTED_KEYS"] = 10;
    values[valuesById[11] = "GET_INDEX_INFO"] = 11;
    values[valuesById[12] = "GET_PRIMARY_KEYS"] = 12;
    values[valuesById[13] = "GET_PROCEDURE_COLUMNS"] = 13;
    values[valuesById[14] = "GET_PROCEDURES"] = 14;
    values[valuesById[15] = "GET_PSEUDO_COLUMNS"] = 15;
    values[valuesById[16] = "GET_SCHEMAS"] = 16;
    values[valuesById[17] = "GET_SCHEMAS_WITH_ARGS"] = 17;
    values[valuesById[18] = "GET_SUPER_TABLES"] = 18;
    values[valuesById[19] = "GET_SUPER_TYPES"] = 19;
    values[valuesById[20] = "GET_TABLE_PRIVILEGES"] = 20;
    values[valuesById[21] = "GET_TABLES"] = 21;
    values[valuesById[22] = "GET_TABLE_TYPES"] = 22;
    values[valuesById[23] = "GET_TYPE_INFO"] = 23;
    values[valuesById[24] = "GET_UDTS"] = 24;
    values[valuesById[25] = "GET_VERSION_COLUMNS"] = 25;
    return values;
})();

export const MetaDataOperationArgument = $root.MetaDataOperationArgument = (() => {

    /**
     * Properties of a MetaDataOperationArgument.
     * @interface IMetaDataOperationArgument
     * @property {string|null} [stringValue] MetaDataOperationArgument stringValue
     * @property {boolean|null} [boolValue] MetaDataOperationArgument boolValue
     * @property {number|null} [intValue] MetaDataOperationArgument intValue
     * @property {Array.<string>|null} [stringArrayValues] MetaDataOperationArgument stringArrayValues
     * @property {Array.<number>|null} [intArrayValues] MetaDataOperationArgument intArrayValues
     * @property {MetaDataOperationArgument.ArgumentType|null} [type] MetaDataOperationArgument type
     */

    /**
     * Constructs a new MetaDataOperationArgument.
     * @classdesc Represents a MetaDataOperationArgument.
     * @implements IMetaDataOperationArgument
     * @constructor
     * @param {IMetaDataOperationArgument=} [properties] Properties to set
     */
    function MetaDataOperationArgument(properties) {
        this.stringArrayValues = [];
        this.intArrayValues = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MetaDataOperationArgument stringValue.
     * @member {string} stringValue
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.stringValue = "";

    /**
     * MetaDataOperationArgument boolValue.
     * @member {boolean} boolValue
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.boolValue = false;

    /**
     * MetaDataOperationArgument intValue.
     * @member {number} intValue
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.intValue = 0;

    /**
     * MetaDataOperationArgument stringArrayValues.
     * @member {Array.<string>} stringArrayValues
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.stringArrayValues = $util.emptyArray;

    /**
     * MetaDataOperationArgument intArrayValues.
     * @member {Array.<number>} intArrayValues
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.intArrayValues = $util.emptyArray;

    /**
     * MetaDataOperationArgument type.
     * @member {MetaDataOperationArgument.ArgumentType} type
     * @memberof MetaDataOperationArgument
     * @instance
     */
    MetaDataOperationArgument.prototype.type = 0;

    /**
     * Creates a new MetaDataOperationArgument instance using the specified properties.
     * @function create
     * @memberof MetaDataOperationArgument
     * @static
     * @param {IMetaDataOperationArgument=} [properties] Properties to set
     * @returns {MetaDataOperationArgument} MetaDataOperationArgument instance
     */
    MetaDataOperationArgument.create = function create(properties) {
        return new MetaDataOperationArgument(properties);
    };

    /**
     * Encodes the specified MetaDataOperationArgument message. Does not implicitly {@link MetaDataOperationArgument.verify|verify} messages.
     * @function encode
     * @memberof MetaDataOperationArgument
     * @static
     * @param {IMetaDataOperationArgument} message MetaDataOperationArgument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MetaDataOperationArgument.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
        if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.boolValue);
        if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.intValue);
        if (message.stringArrayValues != null && message.stringArrayValues.length)
            for (let i = 0; i < message.stringArrayValues.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stringArrayValues[i]);
        if (message.intArrayValues != null && message.intArrayValues.length) {
            writer.uint32(/* id 5, wireType 2 =*/42).fork();
            for (let i = 0; i < message.intArrayValues.length; ++i)
                writer.sint32(message.intArrayValues[i]);
            writer.ldelim();
        }
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified MetaDataOperationArgument message, length delimited. Does not implicitly {@link MetaDataOperationArgument.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MetaDataOperationArgument
     * @static
     * @param {IMetaDataOperationArgument} message MetaDataOperationArgument message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MetaDataOperationArgument.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MetaDataOperationArgument message from the specified reader or buffer.
     * @function decode
     * @memberof MetaDataOperationArgument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MetaDataOperationArgument} MetaDataOperationArgument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MetaDataOperationArgument.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MetaDataOperationArgument();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.stringValue = reader.string();
                    break;
                }
            case 2: {
                    message.boolValue = reader.bool();
                    break;
                }
            case 3: {
                    message.intValue = reader.sint32();
                    break;
                }
            case 4: {
                    if (!(message.stringArrayValues && message.stringArrayValues.length))
                        message.stringArrayValues = [];
                    message.stringArrayValues.push(reader.string());
                    break;
                }
            case 5: {
                    if (!(message.intArrayValues && message.intArrayValues.length))
                        message.intArrayValues = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.intArrayValues.push(reader.sint32());
                    } else
                        message.intArrayValues.push(reader.sint32());
                    break;
                }
            case 6: {
                    message.type = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a MetaDataOperationArgument message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MetaDataOperationArgument
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MetaDataOperationArgument} MetaDataOperationArgument
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MetaDataOperationArgument.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MetaDataOperationArgument message.
     * @function verify
     * @memberof MetaDataOperationArgument
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MetaDataOperationArgument.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            if (!$util.isString(message.stringValue))
                return "stringValue: string expected";
        if (message.boolValue != null && message.hasOwnProperty("boolValue"))
            if (typeof message.boolValue !== "boolean")
                return "boolValue: boolean expected";
        if (message.intValue != null && message.hasOwnProperty("intValue"))
            if (!$util.isInteger(message.intValue))
                return "intValue: integer expected";
        if (message.stringArrayValues != null && message.hasOwnProperty("stringArrayValues")) {
            if (!Array.isArray(message.stringArrayValues))
                return "stringArrayValues: array expected";
            for (let i = 0; i < message.stringArrayValues.length; ++i)
                if (!$util.isString(message.stringArrayValues[i]))
                    return "stringArrayValues: string[] expected";
        }
        if (message.intArrayValues != null && message.hasOwnProperty("intArrayValues")) {
            if (!Array.isArray(message.intArrayValues))
                return "intArrayValues: array expected";
            for (let i = 0; i < message.intArrayValues.length; ++i)
                if (!$util.isInteger(message.intArrayValues[i]))
                    return "intArrayValues: integer[] expected";
        }
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
        return null;
    };

    /**
     * Creates a MetaDataOperationArgument message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MetaDataOperationArgument
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MetaDataOperationArgument} MetaDataOperationArgument
     */
    MetaDataOperationArgument.fromObject = function fromObject(object) {
        if (object instanceof $root.MetaDataOperationArgument)
            return object;
        let message = new $root.MetaDataOperationArgument();
        if (object.stringValue != null)
            message.stringValue = String(object.stringValue);
        if (object.boolValue != null)
            message.boolValue = Boolean(object.boolValue);
        if (object.intValue != null)
            message.intValue = object.intValue | 0;
        if (object.stringArrayValues) {
            if (!Array.isArray(object.stringArrayValues))
                throw TypeError(".MetaDataOperationArgument.stringArrayValues: array expected");
            message.stringArrayValues = [];
            for (let i = 0; i < object.stringArrayValues.length; ++i)
                message.stringArrayValues[i] = String(object.stringArrayValues[i]);
        }
        if (object.intArrayValues) {
            if (!Array.isArray(object.intArrayValues))
                throw TypeError(".MetaDataOperationArgument.intArrayValues: array expected");
            message.intArrayValues = [];
            for (let i = 0; i < object.intArrayValues.length; ++i)
                message.intArrayValues[i] = object.intArrayValues[i] | 0;
        }
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "STRING":
        case 0:
            message.type = 0;
            break;
        case "BOOL":
        case 1:
            message.type = 1;
            break;
        case "INT":
        case 2:
            message.type = 2;
            break;
        case "REPEATED_STRING":
        case 3:
            message.type = 3;
            break;
        case "REPEATED_INT":
        case 4:
            message.type = 4;
            break;
        case "NULL":
        case 5:
            message.type = 5;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a MetaDataOperationArgument message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MetaDataOperationArgument
     * @static
     * @param {MetaDataOperationArgument} message MetaDataOperationArgument
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MetaDataOperationArgument.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.stringArrayValues = [];
            object.intArrayValues = [];
        }
        if (options.defaults) {
            object.stringValue = "";
            object.boolValue = false;
            object.intValue = 0;
            object.type = options.enums === String ? "STRING" : 0;
        }
        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
            object.stringValue = message.stringValue;
        if (message.boolValue != null && message.hasOwnProperty("boolValue"))
            object.boolValue = message.boolValue;
        if (message.intValue != null && message.hasOwnProperty("intValue"))
            object.intValue = message.intValue;
        if (message.stringArrayValues && message.stringArrayValues.length) {
            object.stringArrayValues = [];
            for (let j = 0; j < message.stringArrayValues.length; ++j)
                object.stringArrayValues[j] = message.stringArrayValues[j];
        }
        if (message.intArrayValues && message.intArrayValues.length) {
            object.intArrayValues = [];
            for (let j = 0; j < message.intArrayValues.length; ++j)
                object.intArrayValues[j] = message.intArrayValues[j];
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.MetaDataOperationArgument.ArgumentType[message.type] === undefined ? message.type : $root.MetaDataOperationArgument.ArgumentType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this MetaDataOperationArgument to JSON.
     * @function toJSON
     * @memberof MetaDataOperationArgument
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MetaDataOperationArgument.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MetaDataOperationArgument
     * @function getTypeUrl
     * @memberof MetaDataOperationArgument
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MetaDataOperationArgument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MetaDataOperationArgument";
    };

    /**
     * ArgumentType enum.
     * @name MetaDataOperationArgument.ArgumentType
     * @enum {number}
     * @property {number} STRING=0 STRING value
     * @property {number} BOOL=1 BOOL value
     * @property {number} INT=2 INT value
     * @property {number} REPEATED_STRING=3 REPEATED_STRING value
     * @property {number} REPEATED_INT=4 REPEATED_INT value
     * @property {number} NULL=5 NULL value
     */
    MetaDataOperationArgument.ArgumentType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "STRING"] = 0;
        values[valuesById[1] = "BOOL"] = 1;
        values[valuesById[2] = "INT"] = 2;
        values[valuesById[3] = "REPEATED_STRING"] = 3;
        values[valuesById[4] = "REPEATED_INT"] = 4;
        values[valuesById[5] = "NULL"] = 5;
        return values;
    })();

    return MetaDataOperationArgument;
})();

/**
 * StateType enum.
 * @enum {number}
 * @property {number} SQL=0 SQL value
 * @property {number} METADATA=1 METADATA value
 */
export const StateType = $root.StateType = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "SQL"] = 0;
    values[valuesById[1] = "METADATA"] = 1;
    return values;
})();

export const QueryState = $root.QueryState = (() => {

    /**
     * Properties of a QueryState.
     * @interface IQueryState
     * @property {StateType|null} [type] QueryState type
     * @property {string|null} [sql] QueryState sql
     * @property {MetaDataOperation|null} [op] QueryState op
     * @property {Array.<IMetaDataOperationArgument>|null} [args] QueryState args
     * @property {boolean|null} [hasArgs] QueryState hasArgs
     * @property {boolean|null} [hasSql] QueryState hasSql
     * @property {boolean|null} [hasOp] QueryState hasOp
     */

    /**
     * Constructs a new QueryState.
     * @classdesc Represents a QueryState.
     * @implements IQueryState
     * @constructor
     * @param {IQueryState=} [properties] Properties to set
     */
    function QueryState(properties) {
        this.args = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * QueryState type.
     * @member {StateType} type
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.type = 0;

    /**
     * QueryState sql.
     * @member {string} sql
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.sql = "";

    /**
     * QueryState op.
     * @member {MetaDataOperation} op
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.op = 0;

    /**
     * QueryState args.
     * @member {Array.<IMetaDataOperationArgument>} args
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.args = $util.emptyArray;

    /**
     * QueryState hasArgs.
     * @member {boolean} hasArgs
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.hasArgs = false;

    /**
     * QueryState hasSql.
     * @member {boolean} hasSql
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.hasSql = false;

    /**
     * QueryState hasOp.
     * @member {boolean} hasOp
     * @memberof QueryState
     * @instance
     */
    QueryState.prototype.hasOp = false;

    /**
     * Creates a new QueryState instance using the specified properties.
     * @function create
     * @memberof QueryState
     * @static
     * @param {IQueryState=} [properties] Properties to set
     * @returns {QueryState} QueryState instance
     */
    QueryState.create = function create(properties) {
        return new QueryState(properties);
    };

    /**
     * Encodes the specified QueryState message. Does not implicitly {@link QueryState.verify|verify} messages.
     * @function encode
     * @memberof QueryState
     * @static
     * @param {IQueryState} message QueryState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryState.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
        if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sql);
        if (message.op != null && Object.hasOwnProperty.call(message, "op"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.op);
        if (message.args != null && message.args.length)
            for (let i = 0; i < message.args.length; ++i)
                $root.MetaDataOperationArgument.encode(message.args[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.hasArgs != null && Object.hasOwnProperty.call(message, "hasArgs"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasArgs);
        if (message.hasSql != null && Object.hasOwnProperty.call(message, "hasSql"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasSql);
        if (message.hasOp != null && Object.hasOwnProperty.call(message, "hasOp"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasOp);
        return writer;
    };

    /**
     * Encodes the specified QueryState message, length delimited. Does not implicitly {@link QueryState.verify|verify} messages.
     * @function encodeDelimited
     * @memberof QueryState
     * @static
     * @param {IQueryState} message QueryState message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    QueryState.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a QueryState message from the specified reader or buffer.
     * @function decode
     * @memberof QueryState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {QueryState} QueryState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryState.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.type = reader.int32();
                    break;
                }
            case 2: {
                    message.sql = reader.string();
                    break;
                }
            case 3: {
                    message.op = reader.int32();
                    break;
                }
            case 4: {
                    if (!(message.args && message.args.length))
                        message.args = [];
                    message.args.push($root.MetaDataOperationArgument.decode(reader, reader.uint32()));
                    break;
                }
            case 5: {
                    message.hasArgs = reader.bool();
                    break;
                }
            case 6: {
                    message.hasSql = reader.bool();
                    break;
                }
            case 7: {
                    message.hasOp = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a QueryState message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof QueryState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {QueryState} QueryState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    QueryState.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a QueryState message.
     * @function verify
     * @memberof QueryState
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    QueryState.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
                break;
            }
        if (message.sql != null && message.hasOwnProperty("sql"))
            if (!$util.isString(message.sql))
                return "sql: string expected";
        if (message.op != null && message.hasOwnProperty("op"))
            switch (message.op) {
            default:
                return "op: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
                break;
            }
        if (message.args != null && message.hasOwnProperty("args")) {
            if (!Array.isArray(message.args))
                return "args: array expected";
            for (let i = 0; i < message.args.length; ++i) {
                let error = $root.MetaDataOperationArgument.verify(message.args[i]);
                if (error)
                    return "args." + error;
            }
        }
        if (message.hasArgs != null && message.hasOwnProperty("hasArgs"))
            if (typeof message.hasArgs !== "boolean")
                return "hasArgs: boolean expected";
        if (message.hasSql != null && message.hasOwnProperty("hasSql"))
            if (typeof message.hasSql !== "boolean")
                return "hasSql: boolean expected";
        if (message.hasOp != null && message.hasOwnProperty("hasOp"))
            if (typeof message.hasOp !== "boolean")
                return "hasOp: boolean expected";
        return null;
    };

    /**
     * Creates a QueryState message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof QueryState
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {QueryState} QueryState
     */
    QueryState.fromObject = function fromObject(object) {
        if (object instanceof $root.QueryState)
            return object;
        let message = new $root.QueryState();
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "SQL":
        case 0:
            message.type = 0;
            break;
        case "METADATA":
        case 1:
            message.type = 1;
            break;
        }
        if (object.sql != null)
            message.sql = String(object.sql);
        switch (object.op) {
        default:
            if (typeof object.op === "number") {
                message.op = object.op;
                break;
            }
            break;
        case "GET_ATTRIBUTES":
        case 0:
            message.op = 0;
            break;
        case "GET_BEST_ROW_IDENTIFIER":
        case 1:
            message.op = 1;
            break;
        case "GET_CATALOGS":
        case 2:
            message.op = 2;
            break;
        case "GET_CLIENT_INFO_PROPERTIES":
        case 3:
            message.op = 3;
            break;
        case "GET_COLUMN_PRIVILEGES":
        case 4:
            message.op = 4;
            break;
        case "GET_COLUMNS":
        case 5:
            message.op = 5;
            break;
        case "GET_CROSS_REFERENCE":
        case 6:
            message.op = 6;
            break;
        case "GET_EXPORTED_KEYS":
        case 7:
            message.op = 7;
            break;
        case "GET_FUNCTION_COLUMNS":
        case 8:
            message.op = 8;
            break;
        case "GET_FUNCTIONS":
        case 9:
            message.op = 9;
            break;
        case "GET_IMPORTED_KEYS":
        case 10:
            message.op = 10;
            break;
        case "GET_INDEX_INFO":
        case 11:
            message.op = 11;
            break;
        case "GET_PRIMARY_KEYS":
        case 12:
            message.op = 12;
            break;
        case "GET_PROCEDURE_COLUMNS":
        case 13:
            message.op = 13;
            break;
        case "GET_PROCEDURES":
        case 14:
            message.op = 14;
            break;
        case "GET_PSEUDO_COLUMNS":
        case 15:
            message.op = 15;
            break;
        case "GET_SCHEMAS":
        case 16:
            message.op = 16;
            break;
        case "GET_SCHEMAS_WITH_ARGS":
        case 17:
            message.op = 17;
            break;
        case "GET_SUPER_TABLES":
        case 18:
            message.op = 18;
            break;
        case "GET_SUPER_TYPES":
        case 19:
            message.op = 19;
            break;
        case "GET_TABLE_PRIVILEGES":
        case 20:
            message.op = 20;
            break;
        case "GET_TABLES":
        case 21:
            message.op = 21;
            break;
        case "GET_TABLE_TYPES":
        case 22:
            message.op = 22;
            break;
        case "GET_TYPE_INFO":
        case 23:
            message.op = 23;
            break;
        case "GET_UDTS":
        case 24:
            message.op = 24;
            break;
        case "GET_VERSION_COLUMNS":
        case 25:
            message.op = 25;
            break;
        }
        if (object.args) {
            if (!Array.isArray(object.args))
                throw TypeError(".QueryState.args: array expected");
            message.args = [];
            for (let i = 0; i < object.args.length; ++i) {
                if (typeof object.args[i] !== "object")
                    throw TypeError(".QueryState.args: object expected");
                message.args[i] = $root.MetaDataOperationArgument.fromObject(object.args[i]);
            }
        }
        if (object.hasArgs != null)
            message.hasArgs = Boolean(object.hasArgs);
        if (object.hasSql != null)
            message.hasSql = Boolean(object.hasSql);
        if (object.hasOp != null)
            message.hasOp = Boolean(object.hasOp);
        return message;
    };

    /**
     * Creates a plain object from a QueryState message. Also converts values to other types if specified.
     * @function toObject
     * @memberof QueryState
     * @static
     * @param {QueryState} message QueryState
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    QueryState.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.args = [];
        if (options.defaults) {
            object.type = options.enums === String ? "SQL" : 0;
            object.sql = "";
            object.op = options.enums === String ? "GET_ATTRIBUTES" : 0;
            object.hasArgs = false;
            object.hasSql = false;
            object.hasOp = false;
        }
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.StateType[message.type] === undefined ? message.type : $root.StateType[message.type] : message.type;
        if (message.sql != null && message.hasOwnProperty("sql"))
            object.sql = message.sql;
        if (message.op != null && message.hasOwnProperty("op"))
            object.op = options.enums === String ? $root.MetaDataOperation[message.op] === undefined ? message.op : $root.MetaDataOperation[message.op] : message.op;
        if (message.args && message.args.length) {
            object.args = [];
            for (let j = 0; j < message.args.length; ++j)
                object.args[j] = $root.MetaDataOperationArgument.toObject(message.args[j], options);
        }
        if (message.hasArgs != null && message.hasOwnProperty("hasArgs"))
            object.hasArgs = message.hasArgs;
        if (message.hasSql != null && message.hasOwnProperty("hasSql"))
            object.hasSql = message.hasSql;
        if (message.hasOp != null && message.hasOwnProperty("hasOp"))
            object.hasOp = message.hasOp;
        return object;
    };

    /**
     * Converts this QueryState to JSON.
     * @function toJSON
     * @memberof QueryState
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    QueryState.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for QueryState
     * @function getTypeUrl
     * @memberof QueryState
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    QueryState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/QueryState";
    };

    return QueryState;
})();

export const ResultSetResponse = $root.ResultSetResponse = (() => {

    /**
     * Properties of a ResultSetResponse.
     * @interface IResultSetResponse
     * @property {string|null} [connectionId] ResultSetResponse connectionId
     * @property {number|null} [statementId] ResultSetResponse statementId
     * @property {boolean|null} [ownStatement] ResultSetResponse ownStatement
     * @property {ISignature|null} [signature] ResultSetResponse signature
     * @property {IFrame|null} [firstFrame] ResultSetResponse firstFrame
     * @property {number|Long|null} [updateCount] ResultSetResponse updateCount
     * @property {IRpcMetadata|null} [metadata] ResultSetResponse metadata
     */

    /**
     * Constructs a new ResultSetResponse.
     * @classdesc Represents a ResultSetResponse.
     * @implements IResultSetResponse
     * @constructor
     * @param {IResultSetResponse=} [properties] Properties to set
     */
    function ResultSetResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ResultSetResponse connectionId.
     * @member {string} connectionId
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.connectionId = "";

    /**
     * ResultSetResponse statementId.
     * @member {number} statementId
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.statementId = 0;

    /**
     * ResultSetResponse ownStatement.
     * @member {boolean} ownStatement
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.ownStatement = false;

    /**
     * ResultSetResponse signature.
     * @member {ISignature|null|undefined} signature
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.signature = null;

    /**
     * ResultSetResponse firstFrame.
     * @member {IFrame|null|undefined} firstFrame
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.firstFrame = null;

    /**
     * ResultSetResponse updateCount.
     * @member {number|Long} updateCount
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.updateCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ResultSetResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof ResultSetResponse
     * @instance
     */
    ResultSetResponse.prototype.metadata = null;

    /**
     * Creates a new ResultSetResponse instance using the specified properties.
     * @function create
     * @memberof ResultSetResponse
     * @static
     * @param {IResultSetResponse=} [properties] Properties to set
     * @returns {ResultSetResponse} ResultSetResponse instance
     */
    ResultSetResponse.create = function create(properties) {
        return new ResultSetResponse(properties);
    };

    /**
     * Encodes the specified ResultSetResponse message. Does not implicitly {@link ResultSetResponse.verify|verify} messages.
     * @function encode
     * @memberof ResultSetResponse
     * @static
     * @param {IResultSetResponse} message ResultSetResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResultSetResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.ownStatement != null && Object.hasOwnProperty.call(message, "ownStatement"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ownStatement);
        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
            $root.Signature.encode(message.signature, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        if (message.firstFrame != null && Object.hasOwnProperty.call(message, "firstFrame"))
            $root.Frame.encode(message.firstFrame, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.updateCount != null && Object.hasOwnProperty.call(message, "updateCount"))
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.updateCount);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ResultSetResponse message, length delimited. Does not implicitly {@link ResultSetResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ResultSetResponse
     * @static
     * @param {IResultSetResponse} message ResultSetResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ResultSetResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ResultSetResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ResultSetResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ResultSetResponse} ResultSetResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResultSetResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ResultSetResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    message.ownStatement = reader.bool();
                    break;
                }
            case 4: {
                    message.signature = $root.Signature.decode(reader, reader.uint32());
                    break;
                }
            case 5: {
                    message.firstFrame = $root.Frame.decode(reader, reader.uint32());
                    break;
                }
            case 6: {
                    message.updateCount = reader.uint64();
                    break;
                }
            case 7: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ResultSetResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ResultSetResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ResultSetResponse} ResultSetResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ResultSetResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ResultSetResponse message.
     * @function verify
     * @memberof ResultSetResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ResultSetResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.ownStatement != null && message.hasOwnProperty("ownStatement"))
            if (typeof message.ownStatement !== "boolean")
                return "ownStatement: boolean expected";
        if (message.signature != null && message.hasOwnProperty("signature")) {
            let error = $root.Signature.verify(message.signature);
            if (error)
                return "signature." + error;
        }
        if (message.firstFrame != null && message.hasOwnProperty("firstFrame")) {
            let error = $root.Frame.verify(message.firstFrame);
            if (error)
                return "firstFrame." + error;
        }
        if (message.updateCount != null && message.hasOwnProperty("updateCount"))
            if (!$util.isInteger(message.updateCount) && !(message.updateCount && $util.isInteger(message.updateCount.low) && $util.isInteger(message.updateCount.high)))
                return "updateCount: integer|Long expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a ResultSetResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ResultSetResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ResultSetResponse} ResultSetResponse
     */
    ResultSetResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ResultSetResponse)
            return object;
        let message = new $root.ResultSetResponse();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.ownStatement != null)
            message.ownStatement = Boolean(object.ownStatement);
        if (object.signature != null) {
            if (typeof object.signature !== "object")
                throw TypeError(".ResultSetResponse.signature: object expected");
            message.signature = $root.Signature.fromObject(object.signature);
        }
        if (object.firstFrame != null) {
            if (typeof object.firstFrame !== "object")
                throw TypeError(".ResultSetResponse.firstFrame: object expected");
            message.firstFrame = $root.Frame.fromObject(object.firstFrame);
        }
        if (object.updateCount != null)
            if ($util.Long)
                (message.updateCount = $util.Long.fromValue(object.updateCount)).unsigned = true;
            else if (typeof object.updateCount === "string")
                message.updateCount = parseInt(object.updateCount, 10);
            else if (typeof object.updateCount === "number")
                message.updateCount = object.updateCount;
            else if (typeof object.updateCount === "object")
                message.updateCount = new $util.LongBits(object.updateCount.low >>> 0, object.updateCount.high >>> 0).toNumber(true);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".ResultSetResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a ResultSetResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ResultSetResponse
     * @static
     * @param {ResultSetResponse} message ResultSetResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ResultSetResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
            object.ownStatement = false;
            object.signature = null;
            object.firstFrame = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.updateCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.updateCount = options.longs === String ? "0" : 0;
            object.metadata = null;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.ownStatement != null && message.hasOwnProperty("ownStatement"))
            object.ownStatement = message.ownStatement;
        if (message.signature != null && message.hasOwnProperty("signature"))
            object.signature = $root.Signature.toObject(message.signature, options);
        if (message.firstFrame != null && message.hasOwnProperty("firstFrame"))
            object.firstFrame = $root.Frame.toObject(message.firstFrame, options);
        if (message.updateCount != null && message.hasOwnProperty("updateCount"))
            if (typeof message.updateCount === "number")
                object.updateCount = options.longs === String ? String(message.updateCount) : message.updateCount;
            else
                object.updateCount = options.longs === String ? $util.Long.prototype.toString.call(message.updateCount) : options.longs === Number ? new $util.LongBits(message.updateCount.low >>> 0, message.updateCount.high >>> 0).toNumber(true) : message.updateCount;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this ResultSetResponse to JSON.
     * @function toJSON
     * @memberof ResultSetResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ResultSetResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ResultSetResponse
     * @function getTypeUrl
     * @memberof ResultSetResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ResultSetResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ResultSetResponse";
    };

    return ResultSetResponse;
})();

export const ExecuteResponse = $root.ExecuteResponse = (() => {

    /**
     * Properties of an ExecuteResponse.
     * @interface IExecuteResponse
     * @property {Array.<IResultSetResponse>|null} [results] ExecuteResponse results
     * @property {boolean|null} [missingStatement] ExecuteResponse missingStatement
     * @property {IRpcMetadata|null} [metadata] ExecuteResponse metadata
     */

    /**
     * Constructs a new ExecuteResponse.
     * @classdesc Represents an ExecuteResponse.
     * @implements IExecuteResponse
     * @constructor
     * @param {IExecuteResponse=} [properties] Properties to set
     */
    function ExecuteResponse(properties) {
        this.results = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExecuteResponse results.
     * @member {Array.<IResultSetResponse>} results
     * @memberof ExecuteResponse
     * @instance
     */
    ExecuteResponse.prototype.results = $util.emptyArray;

    /**
     * ExecuteResponse missingStatement.
     * @member {boolean} missingStatement
     * @memberof ExecuteResponse
     * @instance
     */
    ExecuteResponse.prototype.missingStatement = false;

    /**
     * ExecuteResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof ExecuteResponse
     * @instance
     */
    ExecuteResponse.prototype.metadata = null;

    /**
     * Creates a new ExecuteResponse instance using the specified properties.
     * @function create
     * @memberof ExecuteResponse
     * @static
     * @param {IExecuteResponse=} [properties] Properties to set
     * @returns {ExecuteResponse} ExecuteResponse instance
     */
    ExecuteResponse.create = function create(properties) {
        return new ExecuteResponse(properties);
    };

    /**
     * Encodes the specified ExecuteResponse message. Does not implicitly {@link ExecuteResponse.verify|verify} messages.
     * @function encode
     * @memberof ExecuteResponse
     * @static
     * @param {IExecuteResponse} message ExecuteResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.results != null && message.results.length)
            for (let i = 0; i < message.results.length; ++i)
                $root.ResultSetResponse.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.missingStatement != null && Object.hasOwnProperty.call(message, "missingStatement"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.missingStatement);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ExecuteResponse message, length delimited. Does not implicitly {@link ExecuteResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExecuteResponse
     * @static
     * @param {IExecuteResponse} message ExecuteResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExecuteResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ExecuteResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExecuteResponse} ExecuteResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExecuteResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.ResultSetResponse.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    message.missingStatement = reader.bool();
                    break;
                }
            case 3: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExecuteResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExecuteResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExecuteResponse} ExecuteResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExecuteResponse message.
     * @function verify
     * @memberof ExecuteResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExecuteResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.results != null && message.hasOwnProperty("results")) {
            if (!Array.isArray(message.results))
                return "results: array expected";
            for (let i = 0; i < message.results.length; ++i) {
                let error = $root.ResultSetResponse.verify(message.results[i]);
                if (error)
                    return "results." + error;
            }
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            if (typeof message.missingStatement !== "boolean")
                return "missingStatement: boolean expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates an ExecuteResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExecuteResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExecuteResponse} ExecuteResponse
     */
    ExecuteResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ExecuteResponse)
            return object;
        let message = new $root.ExecuteResponse();
        if (object.results) {
            if (!Array.isArray(object.results))
                throw TypeError(".ExecuteResponse.results: array expected");
            message.results = [];
            for (let i = 0; i < object.results.length; ++i) {
                if (typeof object.results[i] !== "object")
                    throw TypeError(".ExecuteResponse.results: object expected");
                message.results[i] = $root.ResultSetResponse.fromObject(object.results[i]);
            }
        }
        if (object.missingStatement != null)
            message.missingStatement = Boolean(object.missingStatement);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".ExecuteResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from an ExecuteResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExecuteResponse
     * @static
     * @param {ExecuteResponse} message ExecuteResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExecuteResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.results = [];
        if (options.defaults) {
            object.missingStatement = false;
            object.metadata = null;
        }
        if (message.results && message.results.length) {
            object.results = [];
            for (let j = 0; j < message.results.length; ++j)
                object.results[j] = $root.ResultSetResponse.toObject(message.results[j], options);
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            object.missingStatement = message.missingStatement;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this ExecuteResponse to JSON.
     * @function toJSON
     * @memberof ExecuteResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExecuteResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ExecuteResponse
     * @function getTypeUrl
     * @memberof ExecuteResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ExecuteResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ExecuteResponse";
    };

    return ExecuteResponse;
})();

export const PrepareResponse = $root.PrepareResponse = (() => {

    /**
     * Properties of a PrepareResponse.
     * @interface IPrepareResponse
     * @property {IStatementHandle|null} [statement] PrepareResponse statement
     * @property {IRpcMetadata|null} [metadata] PrepareResponse metadata
     */

    /**
     * Constructs a new PrepareResponse.
     * @classdesc Represents a PrepareResponse.
     * @implements IPrepareResponse
     * @constructor
     * @param {IPrepareResponse=} [properties] Properties to set
     */
    function PrepareResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrepareResponse statement.
     * @member {IStatementHandle|null|undefined} statement
     * @memberof PrepareResponse
     * @instance
     */
    PrepareResponse.prototype.statement = null;

    /**
     * PrepareResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof PrepareResponse
     * @instance
     */
    PrepareResponse.prototype.metadata = null;

    /**
     * Creates a new PrepareResponse instance using the specified properties.
     * @function create
     * @memberof PrepareResponse
     * @static
     * @param {IPrepareResponse=} [properties] Properties to set
     * @returns {PrepareResponse} PrepareResponse instance
     */
    PrepareResponse.create = function create(properties) {
        return new PrepareResponse(properties);
    };

    /**
     * Encodes the specified PrepareResponse message. Does not implicitly {@link PrepareResponse.verify|verify} messages.
     * @function encode
     * @memberof PrepareResponse
     * @static
     * @param {IPrepareResponse} message PrepareResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.statement != null && Object.hasOwnProperty.call(message, "statement"))
            $root.StatementHandle.encode(message.statement, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified PrepareResponse message, length delimited. Does not implicitly {@link PrepareResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrepareResponse
     * @static
     * @param {IPrepareResponse} message PrepareResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrepareResponse message from the specified reader or buffer.
     * @function decode
     * @memberof PrepareResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrepareResponse} PrepareResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrepareResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.statement = $root.StatementHandle.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrepareResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrepareResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrepareResponse} PrepareResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrepareResponse message.
     * @function verify
     * @memberof PrepareResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrepareResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.statement != null && message.hasOwnProperty("statement")) {
            let error = $root.StatementHandle.verify(message.statement);
            if (error)
                return "statement." + error;
        }
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a PrepareResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrepareResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrepareResponse} PrepareResponse
     */
    PrepareResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.PrepareResponse)
            return object;
        let message = new $root.PrepareResponse();
        if (object.statement != null) {
            if (typeof object.statement !== "object")
                throw TypeError(".PrepareResponse.statement: object expected");
            message.statement = $root.StatementHandle.fromObject(object.statement);
        }
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".PrepareResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a PrepareResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrepareResponse
     * @static
     * @param {PrepareResponse} message PrepareResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrepareResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.statement = null;
            object.metadata = null;
        }
        if (message.statement != null && message.hasOwnProperty("statement"))
            object.statement = $root.StatementHandle.toObject(message.statement, options);
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this PrepareResponse to JSON.
     * @function toJSON
     * @memberof PrepareResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrepareResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PrepareResponse
     * @function getTypeUrl
     * @memberof PrepareResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PrepareResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PrepareResponse";
    };

    return PrepareResponse;
})();

export const FetchResponse = $root.FetchResponse = (() => {

    /**
     * Properties of a FetchResponse.
     * @interface IFetchResponse
     * @property {IFrame|null} [frame] FetchResponse frame
     * @property {boolean|null} [missingStatement] FetchResponse missingStatement
     * @property {boolean|null} [missingResults] FetchResponse missingResults
     * @property {IRpcMetadata|null} [metadata] FetchResponse metadata
     */

    /**
     * Constructs a new FetchResponse.
     * @classdesc Represents a FetchResponse.
     * @implements IFetchResponse
     * @constructor
     * @param {IFetchResponse=} [properties] Properties to set
     */
    function FetchResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FetchResponse frame.
     * @member {IFrame|null|undefined} frame
     * @memberof FetchResponse
     * @instance
     */
    FetchResponse.prototype.frame = null;

    /**
     * FetchResponse missingStatement.
     * @member {boolean} missingStatement
     * @memberof FetchResponse
     * @instance
     */
    FetchResponse.prototype.missingStatement = false;

    /**
     * FetchResponse missingResults.
     * @member {boolean} missingResults
     * @memberof FetchResponse
     * @instance
     */
    FetchResponse.prototype.missingResults = false;

    /**
     * FetchResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof FetchResponse
     * @instance
     */
    FetchResponse.prototype.metadata = null;

    /**
     * Creates a new FetchResponse instance using the specified properties.
     * @function create
     * @memberof FetchResponse
     * @static
     * @param {IFetchResponse=} [properties] Properties to set
     * @returns {FetchResponse} FetchResponse instance
     */
    FetchResponse.create = function create(properties) {
        return new FetchResponse(properties);
    };

    /**
     * Encodes the specified FetchResponse message. Does not implicitly {@link FetchResponse.verify|verify} messages.
     * @function encode
     * @memberof FetchResponse
     * @static
     * @param {IFetchResponse} message FetchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FetchResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.frame != null && Object.hasOwnProperty.call(message, "frame"))
            $root.Frame.encode(message.frame, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.missingStatement != null && Object.hasOwnProperty.call(message, "missingStatement"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.missingStatement);
        if (message.missingResults != null && Object.hasOwnProperty.call(message, "missingResults"))
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.missingResults);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified FetchResponse message, length delimited. Does not implicitly {@link FetchResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FetchResponse
     * @static
     * @param {IFetchResponse} message FetchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FetchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FetchResponse message from the specified reader or buffer.
     * @function decode
     * @memberof FetchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FetchResponse} FetchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FetchResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FetchResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.frame = $root.Frame.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.missingStatement = reader.bool();
                    break;
                }
            case 3: {
                    message.missingResults = reader.bool();
                    break;
                }
            case 4: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FetchResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FetchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FetchResponse} FetchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FetchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FetchResponse message.
     * @function verify
     * @memberof FetchResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FetchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.frame != null && message.hasOwnProperty("frame")) {
            let error = $root.Frame.verify(message.frame);
            if (error)
                return "frame." + error;
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            if (typeof message.missingStatement !== "boolean")
                return "missingStatement: boolean expected";
        if (message.missingResults != null && message.hasOwnProperty("missingResults"))
            if (typeof message.missingResults !== "boolean")
                return "missingResults: boolean expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a FetchResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FetchResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FetchResponse} FetchResponse
     */
    FetchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.FetchResponse)
            return object;
        let message = new $root.FetchResponse();
        if (object.frame != null) {
            if (typeof object.frame !== "object")
                throw TypeError(".FetchResponse.frame: object expected");
            message.frame = $root.Frame.fromObject(object.frame);
        }
        if (object.missingStatement != null)
            message.missingStatement = Boolean(object.missingStatement);
        if (object.missingResults != null)
            message.missingResults = Boolean(object.missingResults);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".FetchResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a FetchResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FetchResponse
     * @static
     * @param {FetchResponse} message FetchResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FetchResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.frame = null;
            object.missingStatement = false;
            object.missingResults = false;
            object.metadata = null;
        }
        if (message.frame != null && message.hasOwnProperty("frame"))
            object.frame = $root.Frame.toObject(message.frame, options);
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            object.missingStatement = message.missingStatement;
        if (message.missingResults != null && message.hasOwnProperty("missingResults"))
            object.missingResults = message.missingResults;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this FetchResponse to JSON.
     * @function toJSON
     * @memberof FetchResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FetchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for FetchResponse
     * @function getTypeUrl
     * @memberof FetchResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    FetchResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/FetchResponse";
    };

    return FetchResponse;
})();

export const CreateStatementResponse = $root.CreateStatementResponse = (() => {

    /**
     * Properties of a CreateStatementResponse.
     * @interface ICreateStatementResponse
     * @property {string|null} [connectionId] CreateStatementResponse connectionId
     * @property {number|null} [statementId] CreateStatementResponse statementId
     * @property {IRpcMetadata|null} [metadata] CreateStatementResponse metadata
     */

    /**
     * Constructs a new CreateStatementResponse.
     * @classdesc Represents a CreateStatementResponse.
     * @implements ICreateStatementResponse
     * @constructor
     * @param {ICreateStatementResponse=} [properties] Properties to set
     */
    function CreateStatementResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateStatementResponse connectionId.
     * @member {string} connectionId
     * @memberof CreateStatementResponse
     * @instance
     */
    CreateStatementResponse.prototype.connectionId = "";

    /**
     * CreateStatementResponse statementId.
     * @member {number} statementId
     * @memberof CreateStatementResponse
     * @instance
     */
    CreateStatementResponse.prototype.statementId = 0;

    /**
     * CreateStatementResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof CreateStatementResponse
     * @instance
     */
    CreateStatementResponse.prototype.metadata = null;

    /**
     * Creates a new CreateStatementResponse instance using the specified properties.
     * @function create
     * @memberof CreateStatementResponse
     * @static
     * @param {ICreateStatementResponse=} [properties] Properties to set
     * @returns {CreateStatementResponse} CreateStatementResponse instance
     */
    CreateStatementResponse.create = function create(properties) {
        return new CreateStatementResponse(properties);
    };

    /**
     * Encodes the specified CreateStatementResponse message. Does not implicitly {@link CreateStatementResponse.verify|verify} messages.
     * @function encode
     * @memberof CreateStatementResponse
     * @static
     * @param {ICreateStatementResponse} message CreateStatementResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateStatementResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CreateStatementResponse message, length delimited. Does not implicitly {@link CreateStatementResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateStatementResponse
     * @static
     * @param {ICreateStatementResponse} message CreateStatementResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateStatementResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateStatementResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CreateStatementResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateStatementResponse} CreateStatementResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateStatementResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateStatementResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateStatementResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateStatementResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateStatementResponse} CreateStatementResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateStatementResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateStatementResponse message.
     * @function verify
     * @memberof CreateStatementResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateStatementResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a CreateStatementResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateStatementResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateStatementResponse} CreateStatementResponse
     */
    CreateStatementResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateStatementResponse)
            return object;
        let message = new $root.CreateStatementResponse();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".CreateStatementResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a CreateStatementResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateStatementResponse
     * @static
     * @param {CreateStatementResponse} message CreateStatementResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateStatementResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
            object.metadata = null;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this CreateStatementResponse to JSON.
     * @function toJSON
     * @memberof CreateStatementResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateStatementResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CreateStatementResponse
     * @function getTypeUrl
     * @memberof CreateStatementResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CreateStatementResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CreateStatementResponse";
    };

    return CreateStatementResponse;
})();

export const CloseStatementResponse = $root.CloseStatementResponse = (() => {

    /**
     * Properties of a CloseStatementResponse.
     * @interface ICloseStatementResponse
     * @property {IRpcMetadata|null} [metadata] CloseStatementResponse metadata
     */

    /**
     * Constructs a new CloseStatementResponse.
     * @classdesc Represents a CloseStatementResponse.
     * @implements ICloseStatementResponse
     * @constructor
     * @param {ICloseStatementResponse=} [properties] Properties to set
     */
    function CloseStatementResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CloseStatementResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof CloseStatementResponse
     * @instance
     */
    CloseStatementResponse.prototype.metadata = null;

    /**
     * Creates a new CloseStatementResponse instance using the specified properties.
     * @function create
     * @memberof CloseStatementResponse
     * @static
     * @param {ICloseStatementResponse=} [properties] Properties to set
     * @returns {CloseStatementResponse} CloseStatementResponse instance
     */
    CloseStatementResponse.create = function create(properties) {
        return new CloseStatementResponse(properties);
    };

    /**
     * Encodes the specified CloseStatementResponse message. Does not implicitly {@link CloseStatementResponse.verify|verify} messages.
     * @function encode
     * @memberof CloseStatementResponse
     * @static
     * @param {ICloseStatementResponse} message CloseStatementResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseStatementResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CloseStatementResponse message, length delimited. Does not implicitly {@link CloseStatementResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CloseStatementResponse
     * @static
     * @param {ICloseStatementResponse} message CloseStatementResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseStatementResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CloseStatementResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CloseStatementResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CloseStatementResponse} CloseStatementResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseStatementResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CloseStatementResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CloseStatementResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CloseStatementResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CloseStatementResponse} CloseStatementResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseStatementResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CloseStatementResponse message.
     * @function verify
     * @memberof CloseStatementResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CloseStatementResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a CloseStatementResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CloseStatementResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CloseStatementResponse} CloseStatementResponse
     */
    CloseStatementResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CloseStatementResponse)
            return object;
        let message = new $root.CloseStatementResponse();
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".CloseStatementResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a CloseStatementResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CloseStatementResponse
     * @static
     * @param {CloseStatementResponse} message CloseStatementResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CloseStatementResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.metadata = null;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this CloseStatementResponse to JSON.
     * @function toJSON
     * @memberof CloseStatementResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CloseStatementResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CloseStatementResponse
     * @function getTypeUrl
     * @memberof CloseStatementResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CloseStatementResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CloseStatementResponse";
    };

    return CloseStatementResponse;
})();

export const OpenConnectionResponse = $root.OpenConnectionResponse = (() => {

    /**
     * Properties of an OpenConnectionResponse.
     * @interface IOpenConnectionResponse
     * @property {IRpcMetadata|null} [metadata] OpenConnectionResponse metadata
     */

    /**
     * Constructs a new OpenConnectionResponse.
     * @classdesc Represents an OpenConnectionResponse.
     * @implements IOpenConnectionResponse
     * @constructor
     * @param {IOpenConnectionResponse=} [properties] Properties to set
     */
    function OpenConnectionResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenConnectionResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof OpenConnectionResponse
     * @instance
     */
    OpenConnectionResponse.prototype.metadata = null;

    /**
     * Creates a new OpenConnectionResponse instance using the specified properties.
     * @function create
     * @memberof OpenConnectionResponse
     * @static
     * @param {IOpenConnectionResponse=} [properties] Properties to set
     * @returns {OpenConnectionResponse} OpenConnectionResponse instance
     */
    OpenConnectionResponse.create = function create(properties) {
        return new OpenConnectionResponse(properties);
    };

    /**
     * Encodes the specified OpenConnectionResponse message. Does not implicitly {@link OpenConnectionResponse.verify|verify} messages.
     * @function encode
     * @memberof OpenConnectionResponse
     * @static
     * @param {IOpenConnectionResponse} message OpenConnectionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenConnectionResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OpenConnectionResponse message, length delimited. Does not implicitly {@link OpenConnectionResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenConnectionResponse
     * @static
     * @param {IOpenConnectionResponse} message OpenConnectionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenConnectionResponse message from the specified reader or buffer.
     * @function decode
     * @memberof OpenConnectionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenConnectionResponse} OpenConnectionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenConnectionResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenConnectionResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenConnectionResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenConnectionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenConnectionResponse} OpenConnectionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenConnectionResponse message.
     * @function verify
     * @memberof OpenConnectionResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenConnectionResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates an OpenConnectionResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenConnectionResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenConnectionResponse} OpenConnectionResponse
     */
    OpenConnectionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenConnectionResponse)
            return object;
        let message = new $root.OpenConnectionResponse();
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".OpenConnectionResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from an OpenConnectionResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenConnectionResponse
     * @static
     * @param {OpenConnectionResponse} message OpenConnectionResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenConnectionResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.metadata = null;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this OpenConnectionResponse to JSON.
     * @function toJSON
     * @memberof OpenConnectionResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenConnectionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for OpenConnectionResponse
     * @function getTypeUrl
     * @memberof OpenConnectionResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    OpenConnectionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/OpenConnectionResponse";
    };

    return OpenConnectionResponse;
})();

export const CloseConnectionResponse = $root.CloseConnectionResponse = (() => {

    /**
     * Properties of a CloseConnectionResponse.
     * @interface ICloseConnectionResponse
     * @property {IRpcMetadata|null} [metadata] CloseConnectionResponse metadata
     */

    /**
     * Constructs a new CloseConnectionResponse.
     * @classdesc Represents a CloseConnectionResponse.
     * @implements ICloseConnectionResponse
     * @constructor
     * @param {ICloseConnectionResponse=} [properties] Properties to set
     */
    function CloseConnectionResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CloseConnectionResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof CloseConnectionResponse
     * @instance
     */
    CloseConnectionResponse.prototype.metadata = null;

    /**
     * Creates a new CloseConnectionResponse instance using the specified properties.
     * @function create
     * @memberof CloseConnectionResponse
     * @static
     * @param {ICloseConnectionResponse=} [properties] Properties to set
     * @returns {CloseConnectionResponse} CloseConnectionResponse instance
     */
    CloseConnectionResponse.create = function create(properties) {
        return new CloseConnectionResponse(properties);
    };

    /**
     * Encodes the specified CloseConnectionResponse message. Does not implicitly {@link CloseConnectionResponse.verify|verify} messages.
     * @function encode
     * @memberof CloseConnectionResponse
     * @static
     * @param {ICloseConnectionResponse} message CloseConnectionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseConnectionResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified CloseConnectionResponse message, length delimited. Does not implicitly {@link CloseConnectionResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CloseConnectionResponse
     * @static
     * @param {ICloseConnectionResponse} message CloseConnectionResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseConnectionResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CloseConnectionResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CloseConnectionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CloseConnectionResponse} CloseConnectionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseConnectionResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CloseConnectionResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CloseConnectionResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CloseConnectionResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CloseConnectionResponse} CloseConnectionResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseConnectionResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CloseConnectionResponse message.
     * @function verify
     * @memberof CloseConnectionResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CloseConnectionResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a CloseConnectionResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CloseConnectionResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CloseConnectionResponse} CloseConnectionResponse
     */
    CloseConnectionResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CloseConnectionResponse)
            return object;
        let message = new $root.CloseConnectionResponse();
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".CloseConnectionResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a CloseConnectionResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CloseConnectionResponse
     * @static
     * @param {CloseConnectionResponse} message CloseConnectionResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CloseConnectionResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.metadata = null;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this CloseConnectionResponse to JSON.
     * @function toJSON
     * @memberof CloseConnectionResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CloseConnectionResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CloseConnectionResponse
     * @function getTypeUrl
     * @memberof CloseConnectionResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CloseConnectionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CloseConnectionResponse";
    };

    return CloseConnectionResponse;
})();

export const ConnectionSyncResponse = $root.ConnectionSyncResponse = (() => {

    /**
     * Properties of a ConnectionSyncResponse.
     * @interface IConnectionSyncResponse
     * @property {IConnectionProperties|null} [connProps] ConnectionSyncResponse connProps
     * @property {IRpcMetadata|null} [metadata] ConnectionSyncResponse metadata
     */

    /**
     * Constructs a new ConnectionSyncResponse.
     * @classdesc Represents a ConnectionSyncResponse.
     * @implements IConnectionSyncResponse
     * @constructor
     * @param {IConnectionSyncResponse=} [properties] Properties to set
     */
    function ConnectionSyncResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConnectionSyncResponse connProps.
     * @member {IConnectionProperties|null|undefined} connProps
     * @memberof ConnectionSyncResponse
     * @instance
     */
    ConnectionSyncResponse.prototype.connProps = null;

    /**
     * ConnectionSyncResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof ConnectionSyncResponse
     * @instance
     */
    ConnectionSyncResponse.prototype.metadata = null;

    /**
     * Creates a new ConnectionSyncResponse instance using the specified properties.
     * @function create
     * @memberof ConnectionSyncResponse
     * @static
     * @param {IConnectionSyncResponse=} [properties] Properties to set
     * @returns {ConnectionSyncResponse} ConnectionSyncResponse instance
     */
    ConnectionSyncResponse.create = function create(properties) {
        return new ConnectionSyncResponse(properties);
    };

    /**
     * Encodes the specified ConnectionSyncResponse message. Does not implicitly {@link ConnectionSyncResponse.verify|verify} messages.
     * @function encode
     * @memberof ConnectionSyncResponse
     * @static
     * @param {IConnectionSyncResponse} message ConnectionSyncResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionSyncResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connProps != null && Object.hasOwnProperty.call(message, "connProps"))
            $root.ConnectionProperties.encode(message.connProps, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConnectionSyncResponse message, length delimited. Does not implicitly {@link ConnectionSyncResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConnectionSyncResponse
     * @static
     * @param {IConnectionSyncResponse} message ConnectionSyncResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionSyncResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConnectionSyncResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ConnectionSyncResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConnectionSyncResponse} ConnectionSyncResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionSyncResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectionSyncResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connProps = $root.ConnectionProperties.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConnectionSyncResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConnectionSyncResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConnectionSyncResponse} ConnectionSyncResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionSyncResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConnectionSyncResponse message.
     * @function verify
     * @memberof ConnectionSyncResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConnectionSyncResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connProps != null && message.hasOwnProperty("connProps")) {
            let error = $root.ConnectionProperties.verify(message.connProps);
            if (error)
                return "connProps." + error;
        }
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a ConnectionSyncResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConnectionSyncResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConnectionSyncResponse} ConnectionSyncResponse
     */
    ConnectionSyncResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ConnectionSyncResponse)
            return object;
        let message = new $root.ConnectionSyncResponse();
        if (object.connProps != null) {
            if (typeof object.connProps !== "object")
                throw TypeError(".ConnectionSyncResponse.connProps: object expected");
            message.connProps = $root.ConnectionProperties.fromObject(object.connProps);
        }
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".ConnectionSyncResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a ConnectionSyncResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConnectionSyncResponse
     * @static
     * @param {ConnectionSyncResponse} message ConnectionSyncResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConnectionSyncResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connProps = null;
            object.metadata = null;
        }
        if (message.connProps != null && message.hasOwnProperty("connProps"))
            object.connProps = $root.ConnectionProperties.toObject(message.connProps, options);
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this ConnectionSyncResponse to JSON.
     * @function toJSON
     * @memberof ConnectionSyncResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConnectionSyncResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ConnectionSyncResponse
     * @function getTypeUrl
     * @memberof ConnectionSyncResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ConnectionSyncResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ConnectionSyncResponse";
    };

    return ConnectionSyncResponse;
})();

export const DatabasePropertyElement = $root.DatabasePropertyElement = (() => {

    /**
     * Properties of a DatabasePropertyElement.
     * @interface IDatabasePropertyElement
     * @property {IDatabaseProperty|null} [key] DatabasePropertyElement key
     * @property {ITypedValue|null} [value] DatabasePropertyElement value
     * @property {IRpcMetadata|null} [metadata] DatabasePropertyElement metadata
     */

    /**
     * Constructs a new DatabasePropertyElement.
     * @classdesc Represents a DatabasePropertyElement.
     * @implements IDatabasePropertyElement
     * @constructor
     * @param {IDatabasePropertyElement=} [properties] Properties to set
     */
    function DatabasePropertyElement(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DatabasePropertyElement key.
     * @member {IDatabaseProperty|null|undefined} key
     * @memberof DatabasePropertyElement
     * @instance
     */
    DatabasePropertyElement.prototype.key = null;

    /**
     * DatabasePropertyElement value.
     * @member {ITypedValue|null|undefined} value
     * @memberof DatabasePropertyElement
     * @instance
     */
    DatabasePropertyElement.prototype.value = null;

    /**
     * DatabasePropertyElement metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof DatabasePropertyElement
     * @instance
     */
    DatabasePropertyElement.prototype.metadata = null;

    /**
     * Creates a new DatabasePropertyElement instance using the specified properties.
     * @function create
     * @memberof DatabasePropertyElement
     * @static
     * @param {IDatabasePropertyElement=} [properties] Properties to set
     * @returns {DatabasePropertyElement} DatabasePropertyElement instance
     */
    DatabasePropertyElement.create = function create(properties) {
        return new DatabasePropertyElement(properties);
    };

    /**
     * Encodes the specified DatabasePropertyElement message. Does not implicitly {@link DatabasePropertyElement.verify|verify} messages.
     * @function encode
     * @memberof DatabasePropertyElement
     * @static
     * @param {IDatabasePropertyElement} message DatabasePropertyElement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyElement.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            $root.DatabaseProperty.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            $root.TypedValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DatabasePropertyElement message, length delimited. Does not implicitly {@link DatabasePropertyElement.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DatabasePropertyElement
     * @static
     * @param {IDatabasePropertyElement} message DatabasePropertyElement message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyElement.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DatabasePropertyElement message from the specified reader or buffer.
     * @function decode
     * @memberof DatabasePropertyElement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DatabasePropertyElement} DatabasePropertyElement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyElement.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DatabasePropertyElement();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.key = $root.DatabaseProperty.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.value = $root.TypedValue.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DatabasePropertyElement message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DatabasePropertyElement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DatabasePropertyElement} DatabasePropertyElement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyElement.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DatabasePropertyElement message.
     * @function verify
     * @memberof DatabasePropertyElement
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DatabasePropertyElement.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.key != null && message.hasOwnProperty("key")) {
            let error = $root.DatabaseProperty.verify(message.key);
            if (error)
                return "key." + error;
        }
        if (message.value != null && message.hasOwnProperty("value")) {
            let error = $root.TypedValue.verify(message.value);
            if (error)
                return "value." + error;
        }
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a DatabasePropertyElement message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DatabasePropertyElement
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DatabasePropertyElement} DatabasePropertyElement
     */
    DatabasePropertyElement.fromObject = function fromObject(object) {
        if (object instanceof $root.DatabasePropertyElement)
            return object;
        let message = new $root.DatabasePropertyElement();
        if (object.key != null) {
            if (typeof object.key !== "object")
                throw TypeError(".DatabasePropertyElement.key: object expected");
            message.key = $root.DatabaseProperty.fromObject(object.key);
        }
        if (object.value != null) {
            if (typeof object.value !== "object")
                throw TypeError(".DatabasePropertyElement.value: object expected");
            message.value = $root.TypedValue.fromObject(object.value);
        }
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".DatabasePropertyElement.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a DatabasePropertyElement message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DatabasePropertyElement
     * @static
     * @param {DatabasePropertyElement} message DatabasePropertyElement
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DatabasePropertyElement.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.key = null;
            object.value = null;
            object.metadata = null;
        }
        if (message.key != null && message.hasOwnProperty("key"))
            object.key = $root.DatabaseProperty.toObject(message.key, options);
        if (message.value != null && message.hasOwnProperty("value"))
            object.value = $root.TypedValue.toObject(message.value, options);
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this DatabasePropertyElement to JSON.
     * @function toJSON
     * @memberof DatabasePropertyElement
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DatabasePropertyElement.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DatabasePropertyElement
     * @function getTypeUrl
     * @memberof DatabasePropertyElement
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DatabasePropertyElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DatabasePropertyElement";
    };

    return DatabasePropertyElement;
})();

export const DatabasePropertyResponse = $root.DatabasePropertyResponse = (() => {

    /**
     * Properties of a DatabasePropertyResponse.
     * @interface IDatabasePropertyResponse
     * @property {Array.<IDatabasePropertyElement>|null} [props] DatabasePropertyResponse props
     * @property {IRpcMetadata|null} [metadata] DatabasePropertyResponse metadata
     */

    /**
     * Constructs a new DatabasePropertyResponse.
     * @classdesc Represents a DatabasePropertyResponse.
     * @implements IDatabasePropertyResponse
     * @constructor
     * @param {IDatabasePropertyResponse=} [properties] Properties to set
     */
    function DatabasePropertyResponse(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DatabasePropertyResponse props.
     * @member {Array.<IDatabasePropertyElement>} props
     * @memberof DatabasePropertyResponse
     * @instance
     */
    DatabasePropertyResponse.prototype.props = $util.emptyArray;

    /**
     * DatabasePropertyResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof DatabasePropertyResponse
     * @instance
     */
    DatabasePropertyResponse.prototype.metadata = null;

    /**
     * Creates a new DatabasePropertyResponse instance using the specified properties.
     * @function create
     * @memberof DatabasePropertyResponse
     * @static
     * @param {IDatabasePropertyResponse=} [properties] Properties to set
     * @returns {DatabasePropertyResponse} DatabasePropertyResponse instance
     */
    DatabasePropertyResponse.create = function create(properties) {
        return new DatabasePropertyResponse(properties);
    };

    /**
     * Encodes the specified DatabasePropertyResponse message. Does not implicitly {@link DatabasePropertyResponse.verify|verify} messages.
     * @function encode
     * @memberof DatabasePropertyResponse
     * @static
     * @param {IDatabasePropertyResponse} message DatabasePropertyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.props != null && message.props.length)
            for (let i = 0; i < message.props.length; ++i)
                $root.DatabasePropertyElement.encode(message.props[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified DatabasePropertyResponse message, length delimited. Does not implicitly {@link DatabasePropertyResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DatabasePropertyResponse
     * @static
     * @param {IDatabasePropertyResponse} message DatabasePropertyResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DatabasePropertyResponse message from the specified reader or buffer.
     * @function decode
     * @memberof DatabasePropertyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DatabasePropertyResponse} DatabasePropertyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DatabasePropertyResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.DatabasePropertyElement.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DatabasePropertyResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DatabasePropertyResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DatabasePropertyResponse} DatabasePropertyResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DatabasePropertyResponse message.
     * @function verify
     * @memberof DatabasePropertyResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DatabasePropertyResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.props != null && message.hasOwnProperty("props")) {
            if (!Array.isArray(message.props))
                return "props: array expected";
            for (let i = 0; i < message.props.length; ++i) {
                let error = $root.DatabasePropertyElement.verify(message.props[i]);
                if (error)
                    return "props." + error;
            }
        }
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a DatabasePropertyResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DatabasePropertyResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DatabasePropertyResponse} DatabasePropertyResponse
     */
    DatabasePropertyResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.DatabasePropertyResponse)
            return object;
        let message = new $root.DatabasePropertyResponse();
        if (object.props) {
            if (!Array.isArray(object.props))
                throw TypeError(".DatabasePropertyResponse.props: array expected");
            message.props = [];
            for (let i = 0; i < object.props.length; ++i) {
                if (typeof object.props[i] !== "object")
                    throw TypeError(".DatabasePropertyResponse.props: object expected");
                message.props[i] = $root.DatabasePropertyElement.fromObject(object.props[i]);
            }
        }
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".DatabasePropertyResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a DatabasePropertyResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DatabasePropertyResponse
     * @static
     * @param {DatabasePropertyResponse} message DatabasePropertyResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DatabasePropertyResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.props = [];
        if (options.defaults)
            object.metadata = null;
        if (message.props && message.props.length) {
            object.props = [];
            for (let j = 0; j < message.props.length; ++j)
                object.props[j] = $root.DatabasePropertyElement.toObject(message.props[j], options);
        }
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this DatabasePropertyResponse to JSON.
     * @function toJSON
     * @memberof DatabasePropertyResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DatabasePropertyResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DatabasePropertyResponse
     * @function getTypeUrl
     * @memberof DatabasePropertyResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DatabasePropertyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DatabasePropertyResponse";
    };

    return DatabasePropertyResponse;
})();

export const ErrorResponse = $root.ErrorResponse = (() => {

    /**
     * Properties of an ErrorResponse.
     * @interface IErrorResponse
     * @property {Array.<string>|null} [exceptions] ErrorResponse exceptions
     * @property {boolean|null} [hasExceptions] ErrorResponse hasExceptions
     * @property {string|null} [errorMessage] ErrorResponse errorMessage
     * @property {Severity|null} [severity] ErrorResponse severity
     * @property {number|null} [errorCode] ErrorResponse errorCode
     * @property {string|null} [sqlState] ErrorResponse sqlState
     * @property {IRpcMetadata|null} [metadata] ErrorResponse metadata
     */

    /**
     * Constructs a new ErrorResponse.
     * @classdesc Represents an ErrorResponse.
     * @implements IErrorResponse
     * @constructor
     * @param {IErrorResponse=} [properties] Properties to set
     */
    function ErrorResponse(properties) {
        this.exceptions = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ErrorResponse exceptions.
     * @member {Array.<string>} exceptions
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.exceptions = $util.emptyArray;

    /**
     * ErrorResponse hasExceptions.
     * @member {boolean} hasExceptions
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.hasExceptions = false;

    /**
     * ErrorResponse errorMessage.
     * @member {string} errorMessage
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.errorMessage = "";

    /**
     * ErrorResponse severity.
     * @member {Severity} severity
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.severity = 0;

    /**
     * ErrorResponse errorCode.
     * @member {number} errorCode
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.errorCode = 0;

    /**
     * ErrorResponse sqlState.
     * @member {string} sqlState
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.sqlState = "";

    /**
     * ErrorResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof ErrorResponse
     * @instance
     */
    ErrorResponse.prototype.metadata = null;

    /**
     * Creates a new ErrorResponse instance using the specified properties.
     * @function create
     * @memberof ErrorResponse
     * @static
     * @param {IErrorResponse=} [properties] Properties to set
     * @returns {ErrorResponse} ErrorResponse instance
     */
    ErrorResponse.create = function create(properties) {
        return new ErrorResponse(properties);
    };

    /**
     * Encodes the specified ErrorResponse message. Does not implicitly {@link ErrorResponse.verify|verify} messages.
     * @function encode
     * @memberof ErrorResponse
     * @static
     * @param {IErrorResponse} message ErrorResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ErrorResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.exceptions != null && message.exceptions.length)
            for (let i = 0; i < message.exceptions.length; ++i)
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.exceptions[i]);
        if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
        if (message.severity != null && Object.hasOwnProperty.call(message, "severity"))
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.severity);
        if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.errorCode);
        if (message.sqlState != null && Object.hasOwnProperty.call(message, "sqlState"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.sqlState);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.hasExceptions != null && Object.hasOwnProperty.call(message, "hasExceptions"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasExceptions);
        return writer;
    };

    /**
     * Encodes the specified ErrorResponse message, length delimited. Does not implicitly {@link ErrorResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ErrorResponse
     * @static
     * @param {IErrorResponse} message ErrorResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ErrorResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ErrorResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ErrorResponse} ErrorResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ErrorResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ErrorResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.exceptions && message.exceptions.length))
                        message.exceptions = [];
                    message.exceptions.push(reader.string());
                    break;
                }
            case 7: {
                    message.hasExceptions = reader.bool();
                    break;
                }
            case 2: {
                    message.errorMessage = reader.string();
                    break;
                }
            case 3: {
                    message.severity = reader.int32();
                    break;
                }
            case 4: {
                    message.errorCode = reader.uint32();
                    break;
                }
            case 5: {
                    message.sqlState = reader.string();
                    break;
                }
            case 6: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ErrorResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ErrorResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ErrorResponse} ErrorResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ErrorResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ErrorResponse message.
     * @function verify
     * @memberof ErrorResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ErrorResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.exceptions != null && message.hasOwnProperty("exceptions")) {
            if (!Array.isArray(message.exceptions))
                return "exceptions: array expected";
            for (let i = 0; i < message.exceptions.length; ++i)
                if (!$util.isString(message.exceptions[i]))
                    return "exceptions: string[] expected";
        }
        if (message.hasExceptions != null && message.hasOwnProperty("hasExceptions"))
            if (typeof message.hasExceptions !== "boolean")
                return "hasExceptions: boolean expected";
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            if (!$util.isString(message.errorMessage))
                return "errorMessage: string expected";
        if (message.severity != null && message.hasOwnProperty("severity"))
            switch (message.severity) {
            default:
                return "severity: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
        if (message.errorCode != null && message.hasOwnProperty("errorCode"))
            if (!$util.isInteger(message.errorCode))
                return "errorCode: integer expected";
        if (message.sqlState != null && message.hasOwnProperty("sqlState"))
            if (!$util.isString(message.sqlState))
                return "sqlState: string expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates an ErrorResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ErrorResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ErrorResponse} ErrorResponse
     */
    ErrorResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ErrorResponse)
            return object;
        let message = new $root.ErrorResponse();
        if (object.exceptions) {
            if (!Array.isArray(object.exceptions))
                throw TypeError(".ErrorResponse.exceptions: array expected");
            message.exceptions = [];
            for (let i = 0; i < object.exceptions.length; ++i)
                message.exceptions[i] = String(object.exceptions[i]);
        }
        if (object.hasExceptions != null)
            message.hasExceptions = Boolean(object.hasExceptions);
        if (object.errorMessage != null)
            message.errorMessage = String(object.errorMessage);
        switch (object.severity) {
        default:
            if (typeof object.severity === "number") {
                message.severity = object.severity;
                break;
            }
            break;
        case "UNKNOWN_SEVERITY":
        case 0:
            message.severity = 0;
            break;
        case "FATAL_SEVERITY":
        case 1:
            message.severity = 1;
            break;
        case "ERROR_SEVERITY":
        case 2:
            message.severity = 2;
            break;
        case "WARNING_SEVERITY":
        case 3:
            message.severity = 3;
            break;
        }
        if (object.errorCode != null)
            message.errorCode = object.errorCode >>> 0;
        if (object.sqlState != null)
            message.sqlState = String(object.sqlState);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".ErrorResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from an ErrorResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ErrorResponse
     * @static
     * @param {ErrorResponse} message ErrorResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ErrorResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.exceptions = [];
        if (options.defaults) {
            object.errorMessage = "";
            object.severity = options.enums === String ? "UNKNOWN_SEVERITY" : 0;
            object.errorCode = 0;
            object.sqlState = "";
            object.metadata = null;
            object.hasExceptions = false;
        }
        if (message.exceptions && message.exceptions.length) {
            object.exceptions = [];
            for (let j = 0; j < message.exceptions.length; ++j)
                object.exceptions[j] = message.exceptions[j];
        }
        if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
            object.errorMessage = message.errorMessage;
        if (message.severity != null && message.hasOwnProperty("severity"))
            object.severity = options.enums === String ? $root.Severity[message.severity] === undefined ? message.severity : $root.Severity[message.severity] : message.severity;
        if (message.errorCode != null && message.hasOwnProperty("errorCode"))
            object.errorCode = message.errorCode;
        if (message.sqlState != null && message.hasOwnProperty("sqlState"))
            object.sqlState = message.sqlState;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        if (message.hasExceptions != null && message.hasOwnProperty("hasExceptions"))
            object.hasExceptions = message.hasExceptions;
        return object;
    };

    /**
     * Converts this ErrorResponse to JSON.
     * @function toJSON
     * @memberof ErrorResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ErrorResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ErrorResponse
     * @function getTypeUrl
     * @memberof ErrorResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ErrorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ErrorResponse";
    };

    return ErrorResponse;
})();

export const SyncResultsResponse = $root.SyncResultsResponse = (() => {

    /**
     * Properties of a SyncResultsResponse.
     * @interface ISyncResultsResponse
     * @property {boolean|null} [missingStatement] SyncResultsResponse missingStatement
     * @property {boolean|null} [moreResults] SyncResultsResponse moreResults
     * @property {IRpcMetadata|null} [metadata] SyncResultsResponse metadata
     */

    /**
     * Constructs a new SyncResultsResponse.
     * @classdesc Represents a SyncResultsResponse.
     * @implements ISyncResultsResponse
     * @constructor
     * @param {ISyncResultsResponse=} [properties] Properties to set
     */
    function SyncResultsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncResultsResponse missingStatement.
     * @member {boolean} missingStatement
     * @memberof SyncResultsResponse
     * @instance
     */
    SyncResultsResponse.prototype.missingStatement = false;

    /**
     * SyncResultsResponse moreResults.
     * @member {boolean} moreResults
     * @memberof SyncResultsResponse
     * @instance
     */
    SyncResultsResponse.prototype.moreResults = false;

    /**
     * SyncResultsResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof SyncResultsResponse
     * @instance
     */
    SyncResultsResponse.prototype.metadata = null;

    /**
     * Creates a new SyncResultsResponse instance using the specified properties.
     * @function create
     * @memberof SyncResultsResponse
     * @static
     * @param {ISyncResultsResponse=} [properties] Properties to set
     * @returns {SyncResultsResponse} SyncResultsResponse instance
     */
    SyncResultsResponse.create = function create(properties) {
        return new SyncResultsResponse(properties);
    };

    /**
     * Encodes the specified SyncResultsResponse message. Does not implicitly {@link SyncResultsResponse.verify|verify} messages.
     * @function encode
     * @memberof SyncResultsResponse
     * @static
     * @param {ISyncResultsResponse} message SyncResultsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncResultsResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.missingStatement != null && Object.hasOwnProperty.call(message, "missingStatement"))
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.missingStatement);
        if (message.moreResults != null && Object.hasOwnProperty.call(message, "moreResults"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.moreResults);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SyncResultsResponse message, length delimited. Does not implicitly {@link SyncResultsResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncResultsResponse
     * @static
     * @param {ISyncResultsResponse} message SyncResultsResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncResultsResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncResultsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SyncResultsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncResultsResponse} SyncResultsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncResultsResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncResultsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.missingStatement = reader.bool();
                    break;
                }
            case 2: {
                    message.moreResults = reader.bool();
                    break;
                }
            case 3: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncResultsResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncResultsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncResultsResponse} SyncResultsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncResultsResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncResultsResponse message.
     * @function verify
     * @memberof SyncResultsResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncResultsResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            if (typeof message.missingStatement !== "boolean")
                return "missingStatement: boolean expected";
        if (message.moreResults != null && message.hasOwnProperty("moreResults"))
            if (typeof message.moreResults !== "boolean")
                return "moreResults: boolean expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates a SyncResultsResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncResultsResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncResultsResponse} SyncResultsResponse
     */
    SyncResultsResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncResultsResponse)
            return object;
        let message = new $root.SyncResultsResponse();
        if (object.missingStatement != null)
            message.missingStatement = Boolean(object.missingStatement);
        if (object.moreResults != null)
            message.moreResults = Boolean(object.moreResults);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".SyncResultsResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from a SyncResultsResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncResultsResponse
     * @static
     * @param {SyncResultsResponse} message SyncResultsResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncResultsResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.missingStatement = false;
            object.moreResults = false;
            object.metadata = null;
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            object.missingStatement = message.missingStatement;
        if (message.moreResults != null && message.hasOwnProperty("moreResults"))
            object.moreResults = message.moreResults;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this SyncResultsResponse to JSON.
     * @function toJSON
     * @memberof SyncResultsResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncResultsResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SyncResultsResponse
     * @function getTypeUrl
     * @memberof SyncResultsResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SyncResultsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SyncResultsResponse";
    };

    return SyncResultsResponse;
})();

export const RpcMetadata = $root.RpcMetadata = (() => {

    /**
     * Properties of a RpcMetadata.
     * @interface IRpcMetadata
     * @property {string|null} [serverAddress] RpcMetadata serverAddress
     */

    /**
     * Constructs a new RpcMetadata.
     * @classdesc Represents a RpcMetadata.
     * @implements IRpcMetadata
     * @constructor
     * @param {IRpcMetadata=} [properties] Properties to set
     */
    function RpcMetadata(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RpcMetadata serverAddress.
     * @member {string} serverAddress
     * @memberof RpcMetadata
     * @instance
     */
    RpcMetadata.prototype.serverAddress = "";

    /**
     * Creates a new RpcMetadata instance using the specified properties.
     * @function create
     * @memberof RpcMetadata
     * @static
     * @param {IRpcMetadata=} [properties] Properties to set
     * @returns {RpcMetadata} RpcMetadata instance
     */
    RpcMetadata.create = function create(properties) {
        return new RpcMetadata(properties);
    };

    /**
     * Encodes the specified RpcMetadata message. Does not implicitly {@link RpcMetadata.verify|verify} messages.
     * @function encode
     * @memberof RpcMetadata
     * @static
     * @param {IRpcMetadata} message RpcMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RpcMetadata.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.serverAddress != null && Object.hasOwnProperty.call(message, "serverAddress"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverAddress);
        return writer;
    };

    /**
     * Encodes the specified RpcMetadata message, length delimited. Does not implicitly {@link RpcMetadata.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RpcMetadata
     * @static
     * @param {IRpcMetadata} message RpcMetadata message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RpcMetadata.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RpcMetadata message from the specified reader or buffer.
     * @function decode
     * @memberof RpcMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RpcMetadata} RpcMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RpcMetadata.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RpcMetadata();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.serverAddress = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RpcMetadata message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RpcMetadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RpcMetadata} RpcMetadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RpcMetadata.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RpcMetadata message.
     * @function verify
     * @memberof RpcMetadata
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RpcMetadata.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.serverAddress != null && message.hasOwnProperty("serverAddress"))
            if (!$util.isString(message.serverAddress))
                return "serverAddress: string expected";
        return null;
    };

    /**
     * Creates a RpcMetadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RpcMetadata
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RpcMetadata} RpcMetadata
     */
    RpcMetadata.fromObject = function fromObject(object) {
        if (object instanceof $root.RpcMetadata)
            return object;
        let message = new $root.RpcMetadata();
        if (object.serverAddress != null)
            message.serverAddress = String(object.serverAddress);
        return message;
    };

    /**
     * Creates a plain object from a RpcMetadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RpcMetadata
     * @static
     * @param {RpcMetadata} message RpcMetadata
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RpcMetadata.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.serverAddress = "";
        if (message.serverAddress != null && message.hasOwnProperty("serverAddress"))
            object.serverAddress = message.serverAddress;
        return object;
    };

    /**
     * Converts this RpcMetadata to JSON.
     * @function toJSON
     * @memberof RpcMetadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RpcMetadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RpcMetadata
     * @function getTypeUrl
     * @memberof RpcMetadata
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RpcMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RpcMetadata";
    };

    return RpcMetadata;
})();

export const CommitResponse = $root.CommitResponse = (() => {

    /**
     * Properties of a CommitResponse.
     * @interface ICommitResponse
     */

    /**
     * Constructs a new CommitResponse.
     * @classdesc Represents a CommitResponse.
     * @implements ICommitResponse
     * @constructor
     * @param {ICommitResponse=} [properties] Properties to set
     */
    function CommitResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new CommitResponse instance using the specified properties.
     * @function create
     * @memberof CommitResponse
     * @static
     * @param {ICommitResponse=} [properties] Properties to set
     * @returns {CommitResponse} CommitResponse instance
     */
    CommitResponse.create = function create(properties) {
        return new CommitResponse(properties);
    };

    /**
     * Encodes the specified CommitResponse message. Does not implicitly {@link CommitResponse.verify|verify} messages.
     * @function encode
     * @memberof CommitResponse
     * @static
     * @param {ICommitResponse} message CommitResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CommitResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified CommitResponse message, length delimited. Does not implicitly {@link CommitResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CommitResponse
     * @static
     * @param {ICommitResponse} message CommitResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CommitResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CommitResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CommitResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CommitResponse} CommitResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CommitResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommitResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CommitResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CommitResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CommitResponse} CommitResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CommitResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CommitResponse message.
     * @function verify
     * @memberof CommitResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CommitResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a CommitResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CommitResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CommitResponse} CommitResponse
     */
    CommitResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.CommitResponse)
            return object;
        return new $root.CommitResponse();
    };

    /**
     * Creates a plain object from a CommitResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CommitResponse
     * @static
     * @param {CommitResponse} message CommitResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CommitResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this CommitResponse to JSON.
     * @function toJSON
     * @memberof CommitResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CommitResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CommitResponse
     * @function getTypeUrl
     * @memberof CommitResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CommitResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CommitResponse";
    };

    return CommitResponse;
})();

export const RollbackResponse = $root.RollbackResponse = (() => {

    /**
     * Properties of a RollbackResponse.
     * @interface IRollbackResponse
     */

    /**
     * Constructs a new RollbackResponse.
     * @classdesc Represents a RollbackResponse.
     * @implements IRollbackResponse
     * @constructor
     * @param {IRollbackResponse=} [properties] Properties to set
     */
    function RollbackResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Creates a new RollbackResponse instance using the specified properties.
     * @function create
     * @memberof RollbackResponse
     * @static
     * @param {IRollbackResponse=} [properties] Properties to set
     * @returns {RollbackResponse} RollbackResponse instance
     */
    RollbackResponse.create = function create(properties) {
        return new RollbackResponse(properties);
    };

    /**
     * Encodes the specified RollbackResponse message. Does not implicitly {@link RollbackResponse.verify|verify} messages.
     * @function encode
     * @memberof RollbackResponse
     * @static
     * @param {IRollbackResponse} message RollbackResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RollbackResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        return writer;
    };

    /**
     * Encodes the specified RollbackResponse message, length delimited. Does not implicitly {@link RollbackResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RollbackResponse
     * @static
     * @param {IRollbackResponse} message RollbackResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RollbackResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RollbackResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RollbackResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RollbackResponse} RollbackResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RollbackResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RollbackResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RollbackResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RollbackResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RollbackResponse} RollbackResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RollbackResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RollbackResponse message.
     * @function verify
     * @memberof RollbackResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RollbackResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        return null;
    };

    /**
     * Creates a RollbackResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RollbackResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RollbackResponse} RollbackResponse
     */
    RollbackResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RollbackResponse)
            return object;
        return new $root.RollbackResponse();
    };

    /**
     * Creates a plain object from a RollbackResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RollbackResponse
     * @static
     * @param {RollbackResponse} message RollbackResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RollbackResponse.toObject = function toObject() {
        return {};
    };

    /**
     * Converts this RollbackResponse to JSON.
     * @function toJSON
     * @memberof RollbackResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RollbackResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RollbackResponse
     * @function getTypeUrl
     * @memberof RollbackResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RollbackResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RollbackResponse";
    };

    return RollbackResponse;
})();

export const ExecuteBatchResponse = $root.ExecuteBatchResponse = (() => {

    /**
     * Properties of an ExecuteBatchResponse.
     * @interface IExecuteBatchResponse
     * @property {string|null} [connectionId] ExecuteBatchResponse connectionId
     * @property {number|null} [statementId] ExecuteBatchResponse statementId
     * @property {Array.<number|Long>|null} [updateCounts] ExecuteBatchResponse updateCounts
     * @property {boolean|null} [missingStatement] ExecuteBatchResponse missingStatement
     * @property {IRpcMetadata|null} [metadata] ExecuteBatchResponse metadata
     */

    /**
     * Constructs a new ExecuteBatchResponse.
     * @classdesc Represents an ExecuteBatchResponse.
     * @implements IExecuteBatchResponse
     * @constructor
     * @param {IExecuteBatchResponse=} [properties] Properties to set
     */
    function ExecuteBatchResponse(properties) {
        this.updateCounts = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExecuteBatchResponse connectionId.
     * @member {string} connectionId
     * @memberof ExecuteBatchResponse
     * @instance
     */
    ExecuteBatchResponse.prototype.connectionId = "";

    /**
     * ExecuteBatchResponse statementId.
     * @member {number} statementId
     * @memberof ExecuteBatchResponse
     * @instance
     */
    ExecuteBatchResponse.prototype.statementId = 0;

    /**
     * ExecuteBatchResponse updateCounts.
     * @member {Array.<number|Long>} updateCounts
     * @memberof ExecuteBatchResponse
     * @instance
     */
    ExecuteBatchResponse.prototype.updateCounts = $util.emptyArray;

    /**
     * ExecuteBatchResponse missingStatement.
     * @member {boolean} missingStatement
     * @memberof ExecuteBatchResponse
     * @instance
     */
    ExecuteBatchResponse.prototype.missingStatement = false;

    /**
     * ExecuteBatchResponse metadata.
     * @member {IRpcMetadata|null|undefined} metadata
     * @memberof ExecuteBatchResponse
     * @instance
     */
    ExecuteBatchResponse.prototype.metadata = null;

    /**
     * Creates a new ExecuteBatchResponse instance using the specified properties.
     * @function create
     * @memberof ExecuteBatchResponse
     * @static
     * @param {IExecuteBatchResponse=} [properties] Properties to set
     * @returns {ExecuteBatchResponse} ExecuteBatchResponse instance
     */
    ExecuteBatchResponse.create = function create(properties) {
        return new ExecuteBatchResponse(properties);
    };

    /**
     * Encodes the specified ExecuteBatchResponse message. Does not implicitly {@link ExecuteBatchResponse.verify|verify} messages.
     * @function encode
     * @memberof ExecuteBatchResponse
     * @static
     * @param {IExecuteBatchResponse} message ExecuteBatchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteBatchResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.updateCounts != null && message.updateCounts.length) {
            writer.uint32(/* id 3, wireType 2 =*/26).fork();
            for (let i = 0; i < message.updateCounts.length; ++i)
                writer.uint64(message.updateCounts[i]);
            writer.ldelim();
        }
        if (message.missingStatement != null && Object.hasOwnProperty.call(message, "missingStatement"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.missingStatement);
        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
            $root.RpcMetadata.encode(message.metadata, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ExecuteBatchResponse message, length delimited. Does not implicitly {@link ExecuteBatchResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExecuteBatchResponse
     * @static
     * @param {IExecuteBatchResponse} message ExecuteBatchResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteBatchResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExecuteBatchResponse message from the specified reader or buffer.
     * @function decode
     * @memberof ExecuteBatchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExecuteBatchResponse} ExecuteBatchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteBatchResponse.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExecuteBatchResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    if (!(message.updateCounts && message.updateCounts.length))
                        message.updateCounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.updateCounts.push(reader.uint64());
                    } else
                        message.updateCounts.push(reader.uint64());
                    break;
                }
            case 4: {
                    message.missingStatement = reader.bool();
                    break;
                }
            case 5: {
                    message.metadata = $root.RpcMetadata.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExecuteBatchResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExecuteBatchResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExecuteBatchResponse} ExecuteBatchResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteBatchResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExecuteBatchResponse message.
     * @function verify
     * @memberof ExecuteBatchResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExecuteBatchResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.updateCounts != null && message.hasOwnProperty("updateCounts")) {
            if (!Array.isArray(message.updateCounts))
                return "updateCounts: array expected";
            for (let i = 0; i < message.updateCounts.length; ++i)
                if (!$util.isInteger(message.updateCounts[i]) && !(message.updateCounts[i] && $util.isInteger(message.updateCounts[i].low) && $util.isInteger(message.updateCounts[i].high)))
                    return "updateCounts: integer|Long[] expected";
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            if (typeof message.missingStatement !== "boolean")
                return "missingStatement: boolean expected";
        if (message.metadata != null && message.hasOwnProperty("metadata")) {
            let error = $root.RpcMetadata.verify(message.metadata);
            if (error)
                return "metadata." + error;
        }
        return null;
    };

    /**
     * Creates an ExecuteBatchResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExecuteBatchResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExecuteBatchResponse} ExecuteBatchResponse
     */
    ExecuteBatchResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.ExecuteBatchResponse)
            return object;
        let message = new $root.ExecuteBatchResponse();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.updateCounts) {
            if (!Array.isArray(object.updateCounts))
                throw TypeError(".ExecuteBatchResponse.updateCounts: array expected");
            message.updateCounts = [];
            for (let i = 0; i < object.updateCounts.length; ++i)
                if ($util.Long)
                    (message.updateCounts[i] = $util.Long.fromValue(object.updateCounts[i])).unsigned = true;
                else if (typeof object.updateCounts[i] === "string")
                    message.updateCounts[i] = parseInt(object.updateCounts[i], 10);
                else if (typeof object.updateCounts[i] === "number")
                    message.updateCounts[i] = object.updateCounts[i];
                else if (typeof object.updateCounts[i] === "object")
                    message.updateCounts[i] = new $util.LongBits(object.updateCounts[i].low >>> 0, object.updateCounts[i].high >>> 0).toNumber(true);
        }
        if (object.missingStatement != null)
            message.missingStatement = Boolean(object.missingStatement);
        if (object.metadata != null) {
            if (typeof object.metadata !== "object")
                throw TypeError(".ExecuteBatchResponse.metadata: object expected");
            message.metadata = $root.RpcMetadata.fromObject(object.metadata);
        }
        return message;
    };

    /**
     * Creates a plain object from an ExecuteBatchResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExecuteBatchResponse
     * @static
     * @param {ExecuteBatchResponse} message ExecuteBatchResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExecuteBatchResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.updateCounts = [];
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
            object.missingStatement = false;
            object.metadata = null;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.updateCounts && message.updateCounts.length) {
            object.updateCounts = [];
            for (let j = 0; j < message.updateCounts.length; ++j)
                if (typeof message.updateCounts[j] === "number")
                    object.updateCounts[j] = options.longs === String ? String(message.updateCounts[j]) : message.updateCounts[j];
                else
                    object.updateCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.updateCounts[j]) : options.longs === Number ? new $util.LongBits(message.updateCounts[j].low >>> 0, message.updateCounts[j].high >>> 0).toNumber(true) : message.updateCounts[j];
        }
        if (message.missingStatement != null && message.hasOwnProperty("missingStatement"))
            object.missingStatement = message.missingStatement;
        if (message.metadata != null && message.hasOwnProperty("metadata"))
            object.metadata = $root.RpcMetadata.toObject(message.metadata, options);
        return object;
    };

    /**
     * Converts this ExecuteBatchResponse to JSON.
     * @function toJSON
     * @memberof ExecuteBatchResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExecuteBatchResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ExecuteBatchResponse
     * @function getTypeUrl
     * @memberof ExecuteBatchResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ExecuteBatchResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ExecuteBatchResponse";
    };

    return ExecuteBatchResponse;
})();

export const CatalogsRequest = $root.CatalogsRequest = (() => {

    /**
     * Properties of a CatalogsRequest.
     * @interface ICatalogsRequest
     * @property {string|null} [connectionId] CatalogsRequest connectionId
     */

    /**
     * Constructs a new CatalogsRequest.
     * @classdesc Represents a CatalogsRequest.
     * @implements ICatalogsRequest
     * @constructor
     * @param {ICatalogsRequest=} [properties] Properties to set
     */
    function CatalogsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CatalogsRequest connectionId.
     * @member {string} connectionId
     * @memberof CatalogsRequest
     * @instance
     */
    CatalogsRequest.prototype.connectionId = "";

    /**
     * Creates a new CatalogsRequest instance using the specified properties.
     * @function create
     * @memberof CatalogsRequest
     * @static
     * @param {ICatalogsRequest=} [properties] Properties to set
     * @returns {CatalogsRequest} CatalogsRequest instance
     */
    CatalogsRequest.create = function create(properties) {
        return new CatalogsRequest(properties);
    };

    /**
     * Encodes the specified CatalogsRequest message. Does not implicitly {@link CatalogsRequest.verify|verify} messages.
     * @function encode
     * @memberof CatalogsRequest
     * @static
     * @param {ICatalogsRequest} message CatalogsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CatalogsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified CatalogsRequest message, length delimited. Does not implicitly {@link CatalogsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CatalogsRequest
     * @static
     * @param {ICatalogsRequest} message CatalogsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CatalogsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CatalogsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CatalogsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CatalogsRequest} CatalogsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CatalogsRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CatalogsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CatalogsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CatalogsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CatalogsRequest} CatalogsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CatalogsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CatalogsRequest message.
     * @function verify
     * @memberof CatalogsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CatalogsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a CatalogsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CatalogsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CatalogsRequest} CatalogsRequest
     */
    CatalogsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CatalogsRequest)
            return object;
        let message = new $root.CatalogsRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a CatalogsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CatalogsRequest
     * @static
     * @param {CatalogsRequest} message CatalogsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CatalogsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this CatalogsRequest to JSON.
     * @function toJSON
     * @memberof CatalogsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CatalogsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CatalogsRequest
     * @function getTypeUrl
     * @memberof CatalogsRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CatalogsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CatalogsRequest";
    };

    return CatalogsRequest;
})();

export const DatabasePropertyRequest = $root.DatabasePropertyRequest = (() => {

    /**
     * Properties of a DatabasePropertyRequest.
     * @interface IDatabasePropertyRequest
     * @property {string|null} [connectionId] DatabasePropertyRequest connectionId
     */

    /**
     * Constructs a new DatabasePropertyRequest.
     * @classdesc Represents a DatabasePropertyRequest.
     * @implements IDatabasePropertyRequest
     * @constructor
     * @param {IDatabasePropertyRequest=} [properties] Properties to set
     */
    function DatabasePropertyRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * DatabasePropertyRequest connectionId.
     * @member {string} connectionId
     * @memberof DatabasePropertyRequest
     * @instance
     */
    DatabasePropertyRequest.prototype.connectionId = "";

    /**
     * Creates a new DatabasePropertyRequest instance using the specified properties.
     * @function create
     * @memberof DatabasePropertyRequest
     * @static
     * @param {IDatabasePropertyRequest=} [properties] Properties to set
     * @returns {DatabasePropertyRequest} DatabasePropertyRequest instance
     */
    DatabasePropertyRequest.create = function create(properties) {
        return new DatabasePropertyRequest(properties);
    };

    /**
     * Encodes the specified DatabasePropertyRequest message. Does not implicitly {@link DatabasePropertyRequest.verify|verify} messages.
     * @function encode
     * @memberof DatabasePropertyRequest
     * @static
     * @param {IDatabasePropertyRequest} message DatabasePropertyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified DatabasePropertyRequest message, length delimited. Does not implicitly {@link DatabasePropertyRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof DatabasePropertyRequest
     * @static
     * @param {IDatabasePropertyRequest} message DatabasePropertyRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    DatabasePropertyRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a DatabasePropertyRequest message from the specified reader or buffer.
     * @function decode
     * @memberof DatabasePropertyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DatabasePropertyRequest} DatabasePropertyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DatabasePropertyRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a DatabasePropertyRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof DatabasePropertyRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {DatabasePropertyRequest} DatabasePropertyRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DatabasePropertyRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a DatabasePropertyRequest message.
     * @function verify
     * @memberof DatabasePropertyRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    DatabasePropertyRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a DatabasePropertyRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof DatabasePropertyRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {DatabasePropertyRequest} DatabasePropertyRequest
     */
    DatabasePropertyRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.DatabasePropertyRequest)
            return object;
        let message = new $root.DatabasePropertyRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a DatabasePropertyRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof DatabasePropertyRequest
     * @static
     * @param {DatabasePropertyRequest} message DatabasePropertyRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    DatabasePropertyRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this DatabasePropertyRequest to JSON.
     * @function toJSON
     * @memberof DatabasePropertyRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    DatabasePropertyRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for DatabasePropertyRequest
     * @function getTypeUrl
     * @memberof DatabasePropertyRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    DatabasePropertyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/DatabasePropertyRequest";
    };

    return DatabasePropertyRequest;
})();

export const SchemasRequest = $root.SchemasRequest = (() => {

    /**
     * Properties of a SchemasRequest.
     * @interface ISchemasRequest
     * @property {string|null} [catalog] SchemasRequest catalog
     * @property {string|null} [schemaPattern] SchemasRequest schemaPattern
     * @property {string|null} [connectionId] SchemasRequest connectionId
     * @property {boolean|null} [hasCatalog] SchemasRequest hasCatalog
     * @property {boolean|null} [hasSchemaPattern] SchemasRequest hasSchemaPattern
     */

    /**
     * Constructs a new SchemasRequest.
     * @classdesc Represents a SchemasRequest.
     * @implements ISchemasRequest
     * @constructor
     * @param {ISchemasRequest=} [properties] Properties to set
     */
    function SchemasRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SchemasRequest catalog.
     * @member {string} catalog
     * @memberof SchemasRequest
     * @instance
     */
    SchemasRequest.prototype.catalog = "";

    /**
     * SchemasRequest schemaPattern.
     * @member {string} schemaPattern
     * @memberof SchemasRequest
     * @instance
     */
    SchemasRequest.prototype.schemaPattern = "";

    /**
     * SchemasRequest connectionId.
     * @member {string} connectionId
     * @memberof SchemasRequest
     * @instance
     */
    SchemasRequest.prototype.connectionId = "";

    /**
     * SchemasRequest hasCatalog.
     * @member {boolean} hasCatalog
     * @memberof SchemasRequest
     * @instance
     */
    SchemasRequest.prototype.hasCatalog = false;

    /**
     * SchemasRequest hasSchemaPattern.
     * @member {boolean} hasSchemaPattern
     * @memberof SchemasRequest
     * @instance
     */
    SchemasRequest.prototype.hasSchemaPattern = false;

    /**
     * Creates a new SchemasRequest instance using the specified properties.
     * @function create
     * @memberof SchemasRequest
     * @static
     * @param {ISchemasRequest=} [properties] Properties to set
     * @returns {SchemasRequest} SchemasRequest instance
     */
    SchemasRequest.create = function create(properties) {
        return new SchemasRequest(properties);
    };

    /**
     * Encodes the specified SchemasRequest message. Does not implicitly {@link SchemasRequest.verify|verify} messages.
     * @function encode
     * @memberof SchemasRequest
     * @static
     * @param {ISchemasRequest} message SchemasRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SchemasRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.catalog);
        if (message.schemaPattern != null && Object.hasOwnProperty.call(message, "schemaPattern"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaPattern);
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.connectionId);
        if (message.hasCatalog != null && Object.hasOwnProperty.call(message, "hasCatalog"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.hasCatalog);
        if (message.hasSchemaPattern != null && Object.hasOwnProperty.call(message, "hasSchemaPattern"))
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.hasSchemaPattern);
        return writer;
    };

    /**
     * Encodes the specified SchemasRequest message, length delimited. Does not implicitly {@link SchemasRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SchemasRequest
     * @static
     * @param {ISchemasRequest} message SchemasRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SchemasRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SchemasRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SchemasRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SchemasRequest} SchemasRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SchemasRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SchemasRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.catalog = reader.string();
                    break;
                }
            case 2: {
                    message.schemaPattern = reader.string();
                    break;
                }
            case 3: {
                    message.connectionId = reader.string();
                    break;
                }
            case 4: {
                    message.hasCatalog = reader.bool();
                    break;
                }
            case 5: {
                    message.hasSchemaPattern = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SchemasRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SchemasRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SchemasRequest} SchemasRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SchemasRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SchemasRequest message.
     * @function verify
     * @memberof SchemasRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SchemasRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            if (!$util.isString(message.catalog))
                return "catalog: string expected";
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            if (!$util.isString(message.schemaPattern))
                return "schemaPattern: string expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            if (typeof message.hasCatalog !== "boolean")
                return "hasCatalog: boolean expected";
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            if (typeof message.hasSchemaPattern !== "boolean")
                return "hasSchemaPattern: boolean expected";
        return null;
    };

    /**
     * Creates a SchemasRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SchemasRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SchemasRequest} SchemasRequest
     */
    SchemasRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SchemasRequest)
            return object;
        let message = new $root.SchemasRequest();
        if (object.catalog != null)
            message.catalog = String(object.catalog);
        if (object.schemaPattern != null)
            message.schemaPattern = String(object.schemaPattern);
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.hasCatalog != null)
            message.hasCatalog = Boolean(object.hasCatalog);
        if (object.hasSchemaPattern != null)
            message.hasSchemaPattern = Boolean(object.hasSchemaPattern);
        return message;
    };

    /**
     * Creates a plain object from a SchemasRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SchemasRequest
     * @static
     * @param {SchemasRequest} message SchemasRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SchemasRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.catalog = "";
            object.schemaPattern = "";
            object.connectionId = "";
            object.hasCatalog = false;
            object.hasSchemaPattern = false;
        }
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            object.catalog = message.catalog;
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            object.schemaPattern = message.schemaPattern;
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            object.hasCatalog = message.hasCatalog;
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            object.hasSchemaPattern = message.hasSchemaPattern;
        return object;
    };

    /**
     * Converts this SchemasRequest to JSON.
     * @function toJSON
     * @memberof SchemasRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SchemasRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SchemasRequest
     * @function getTypeUrl
     * @memberof SchemasRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SchemasRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SchemasRequest";
    };

    return SchemasRequest;
})();

export const TablesRequest = $root.TablesRequest = (() => {

    /**
     * Properties of a TablesRequest.
     * @interface ITablesRequest
     * @property {string|null} [catalog] TablesRequest catalog
     * @property {string|null} [schemaPattern] TablesRequest schemaPattern
     * @property {string|null} [tableNamePattern] TablesRequest tableNamePattern
     * @property {Array.<string>|null} [typeList] TablesRequest typeList
     * @property {boolean|null} [hasTypeList] TablesRequest hasTypeList
     * @property {string|null} [connectionId] TablesRequest connectionId
     * @property {boolean|null} [hasCatalog] TablesRequest hasCatalog
     * @property {boolean|null} [hasSchemaPattern] TablesRequest hasSchemaPattern
     * @property {boolean|null} [hasTableNamePattern] TablesRequest hasTableNamePattern
     */

    /**
     * Constructs a new TablesRequest.
     * @classdesc Represents a TablesRequest.
     * @implements ITablesRequest
     * @constructor
     * @param {ITablesRequest=} [properties] Properties to set
     */
    function TablesRequest(properties) {
        this.typeList = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TablesRequest catalog.
     * @member {string} catalog
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.catalog = "";

    /**
     * TablesRequest schemaPattern.
     * @member {string} schemaPattern
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.schemaPattern = "";

    /**
     * TablesRequest tableNamePattern.
     * @member {string} tableNamePattern
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.tableNamePattern = "";

    /**
     * TablesRequest typeList.
     * @member {Array.<string>} typeList
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.typeList = $util.emptyArray;

    /**
     * TablesRequest hasTypeList.
     * @member {boolean} hasTypeList
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.hasTypeList = false;

    /**
     * TablesRequest connectionId.
     * @member {string} connectionId
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.connectionId = "";

    /**
     * TablesRequest hasCatalog.
     * @member {boolean} hasCatalog
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.hasCatalog = false;

    /**
     * TablesRequest hasSchemaPattern.
     * @member {boolean} hasSchemaPattern
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.hasSchemaPattern = false;

    /**
     * TablesRequest hasTableNamePattern.
     * @member {boolean} hasTableNamePattern
     * @memberof TablesRequest
     * @instance
     */
    TablesRequest.prototype.hasTableNamePattern = false;

    /**
     * Creates a new TablesRequest instance using the specified properties.
     * @function create
     * @memberof TablesRequest
     * @static
     * @param {ITablesRequest=} [properties] Properties to set
     * @returns {TablesRequest} TablesRequest instance
     */
    TablesRequest.create = function create(properties) {
        return new TablesRequest(properties);
    };

    /**
     * Encodes the specified TablesRequest message. Does not implicitly {@link TablesRequest.verify|verify} messages.
     * @function encode
     * @memberof TablesRequest
     * @static
     * @param {ITablesRequest} message TablesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TablesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.catalog);
        if (message.schemaPattern != null && Object.hasOwnProperty.call(message, "schemaPattern"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaPattern);
        if (message.tableNamePattern != null && Object.hasOwnProperty.call(message, "tableNamePattern"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tableNamePattern);
        if (message.typeList != null && message.typeList.length)
            for (let i = 0; i < message.typeList.length; ++i)
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.typeList[i]);
        if (message.hasTypeList != null && Object.hasOwnProperty.call(message, "hasTypeList"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasTypeList);
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.connectionId);
        if (message.hasCatalog != null && Object.hasOwnProperty.call(message, "hasCatalog"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasCatalog);
        if (message.hasSchemaPattern != null && Object.hasOwnProperty.call(message, "hasSchemaPattern"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasSchemaPattern);
        if (message.hasTableNamePattern != null && Object.hasOwnProperty.call(message, "hasTableNamePattern"))
            writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasTableNamePattern);
        return writer;
    };

    /**
     * Encodes the specified TablesRequest message, length delimited. Does not implicitly {@link TablesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TablesRequest
     * @static
     * @param {ITablesRequest} message TablesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TablesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof TablesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TablesRequest} TablesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TablesRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TablesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.catalog = reader.string();
                    break;
                }
            case 2: {
                    message.schemaPattern = reader.string();
                    break;
                }
            case 3: {
                    message.tableNamePattern = reader.string();
                    break;
                }
            case 4: {
                    if (!(message.typeList && message.typeList.length))
                        message.typeList = [];
                    message.typeList.push(reader.string());
                    break;
                }
            case 6: {
                    message.hasTypeList = reader.bool();
                    break;
                }
            case 7: {
                    message.connectionId = reader.string();
                    break;
                }
            case 8: {
                    message.hasCatalog = reader.bool();
                    break;
                }
            case 9: {
                    message.hasSchemaPattern = reader.bool();
                    break;
                }
            case 10: {
                    message.hasTableNamePattern = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TablesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TablesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TablesRequest} TablesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TablesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TablesRequest message.
     * @function verify
     * @memberof TablesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TablesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            if (!$util.isString(message.catalog))
                return "catalog: string expected";
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            if (!$util.isString(message.schemaPattern))
                return "schemaPattern: string expected";
        if (message.tableNamePattern != null && message.hasOwnProperty("tableNamePattern"))
            if (!$util.isString(message.tableNamePattern))
                return "tableNamePattern: string expected";
        if (message.typeList != null && message.hasOwnProperty("typeList")) {
            if (!Array.isArray(message.typeList))
                return "typeList: array expected";
            for (let i = 0; i < message.typeList.length; ++i)
                if (!$util.isString(message.typeList[i]))
                    return "typeList: string[] expected";
        }
        if (message.hasTypeList != null && message.hasOwnProperty("hasTypeList"))
            if (typeof message.hasTypeList !== "boolean")
                return "hasTypeList: boolean expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            if (typeof message.hasCatalog !== "boolean")
                return "hasCatalog: boolean expected";
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            if (typeof message.hasSchemaPattern !== "boolean")
                return "hasSchemaPattern: boolean expected";
        if (message.hasTableNamePattern != null && message.hasOwnProperty("hasTableNamePattern"))
            if (typeof message.hasTableNamePattern !== "boolean")
                return "hasTableNamePattern: boolean expected";
        return null;
    };

    /**
     * Creates a TablesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TablesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TablesRequest} TablesRequest
     */
    TablesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.TablesRequest)
            return object;
        let message = new $root.TablesRequest();
        if (object.catalog != null)
            message.catalog = String(object.catalog);
        if (object.schemaPattern != null)
            message.schemaPattern = String(object.schemaPattern);
        if (object.tableNamePattern != null)
            message.tableNamePattern = String(object.tableNamePattern);
        if (object.typeList) {
            if (!Array.isArray(object.typeList))
                throw TypeError(".TablesRequest.typeList: array expected");
            message.typeList = [];
            for (let i = 0; i < object.typeList.length; ++i)
                message.typeList[i] = String(object.typeList[i]);
        }
        if (object.hasTypeList != null)
            message.hasTypeList = Boolean(object.hasTypeList);
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.hasCatalog != null)
            message.hasCatalog = Boolean(object.hasCatalog);
        if (object.hasSchemaPattern != null)
            message.hasSchemaPattern = Boolean(object.hasSchemaPattern);
        if (object.hasTableNamePattern != null)
            message.hasTableNamePattern = Boolean(object.hasTableNamePattern);
        return message;
    };

    /**
     * Creates a plain object from a TablesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TablesRequest
     * @static
     * @param {TablesRequest} message TablesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TablesRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.typeList = [];
        if (options.defaults) {
            object.catalog = "";
            object.schemaPattern = "";
            object.tableNamePattern = "";
            object.hasTypeList = false;
            object.connectionId = "";
            object.hasCatalog = false;
            object.hasSchemaPattern = false;
            object.hasTableNamePattern = false;
        }
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            object.catalog = message.catalog;
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            object.schemaPattern = message.schemaPattern;
        if (message.tableNamePattern != null && message.hasOwnProperty("tableNamePattern"))
            object.tableNamePattern = message.tableNamePattern;
        if (message.typeList && message.typeList.length) {
            object.typeList = [];
            for (let j = 0; j < message.typeList.length; ++j)
                object.typeList[j] = message.typeList[j];
        }
        if (message.hasTypeList != null && message.hasOwnProperty("hasTypeList"))
            object.hasTypeList = message.hasTypeList;
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            object.hasCatalog = message.hasCatalog;
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            object.hasSchemaPattern = message.hasSchemaPattern;
        if (message.hasTableNamePattern != null && message.hasOwnProperty("hasTableNamePattern"))
            object.hasTableNamePattern = message.hasTableNamePattern;
        return object;
    };

    /**
     * Converts this TablesRequest to JSON.
     * @function toJSON
     * @memberof TablesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TablesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TablesRequest
     * @function getTypeUrl
     * @memberof TablesRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TablesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TablesRequest";
    };

    return TablesRequest;
})();

export const TableTypesRequest = $root.TableTypesRequest = (() => {

    /**
     * Properties of a TableTypesRequest.
     * @interface ITableTypesRequest
     * @property {string|null} [connectionId] TableTypesRequest connectionId
     */

    /**
     * Constructs a new TableTypesRequest.
     * @classdesc Represents a TableTypesRequest.
     * @implements ITableTypesRequest
     * @constructor
     * @param {ITableTypesRequest=} [properties] Properties to set
     */
    function TableTypesRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TableTypesRequest connectionId.
     * @member {string} connectionId
     * @memberof TableTypesRequest
     * @instance
     */
    TableTypesRequest.prototype.connectionId = "";

    /**
     * Creates a new TableTypesRequest instance using the specified properties.
     * @function create
     * @memberof TableTypesRequest
     * @static
     * @param {ITableTypesRequest=} [properties] Properties to set
     * @returns {TableTypesRequest} TableTypesRequest instance
     */
    TableTypesRequest.create = function create(properties) {
        return new TableTypesRequest(properties);
    };

    /**
     * Encodes the specified TableTypesRequest message. Does not implicitly {@link TableTypesRequest.verify|verify} messages.
     * @function encode
     * @memberof TableTypesRequest
     * @static
     * @param {ITableTypesRequest} message TableTypesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TableTypesRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified TableTypesRequest message, length delimited. Does not implicitly {@link TableTypesRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TableTypesRequest
     * @static
     * @param {ITableTypesRequest} message TableTypesRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TableTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TableTypesRequest message from the specified reader or buffer.
     * @function decode
     * @memberof TableTypesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TableTypesRequest} TableTypesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TableTypesRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TableTypesRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TableTypesRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TableTypesRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TableTypesRequest} TableTypesRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TableTypesRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TableTypesRequest message.
     * @function verify
     * @memberof TableTypesRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TableTypesRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a TableTypesRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TableTypesRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TableTypesRequest} TableTypesRequest
     */
    TableTypesRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.TableTypesRequest)
            return object;
        let message = new $root.TableTypesRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a TableTypesRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TableTypesRequest
     * @static
     * @param {TableTypesRequest} message TableTypesRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TableTypesRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this TableTypesRequest to JSON.
     * @function toJSON
     * @memberof TableTypesRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TableTypesRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TableTypesRequest
     * @function getTypeUrl
     * @memberof TableTypesRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TableTypesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TableTypesRequest";
    };

    return TableTypesRequest;
})();

export const ColumnsRequest = $root.ColumnsRequest = (() => {

    /**
     * Properties of a ColumnsRequest.
     * @interface IColumnsRequest
     * @property {string|null} [catalog] ColumnsRequest catalog
     * @property {string|null} [schemaPattern] ColumnsRequest schemaPattern
     * @property {string|null} [tableNamePattern] ColumnsRequest tableNamePattern
     * @property {string|null} [columnNamePattern] ColumnsRequest columnNamePattern
     * @property {string|null} [connectionId] ColumnsRequest connectionId
     * @property {boolean|null} [hasCatalog] ColumnsRequest hasCatalog
     * @property {boolean|null} [hasSchemaPattern] ColumnsRequest hasSchemaPattern
     * @property {boolean|null} [hasTableNamePattern] ColumnsRequest hasTableNamePattern
     * @property {boolean|null} [hasColumnNamePattern] ColumnsRequest hasColumnNamePattern
     */

    /**
     * Constructs a new ColumnsRequest.
     * @classdesc Represents a ColumnsRequest.
     * @implements IColumnsRequest
     * @constructor
     * @param {IColumnsRequest=} [properties] Properties to set
     */
    function ColumnsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ColumnsRequest catalog.
     * @member {string} catalog
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.catalog = "";

    /**
     * ColumnsRequest schemaPattern.
     * @member {string} schemaPattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.schemaPattern = "";

    /**
     * ColumnsRequest tableNamePattern.
     * @member {string} tableNamePattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.tableNamePattern = "";

    /**
     * ColumnsRequest columnNamePattern.
     * @member {string} columnNamePattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.columnNamePattern = "";

    /**
     * ColumnsRequest connectionId.
     * @member {string} connectionId
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.connectionId = "";

    /**
     * ColumnsRequest hasCatalog.
     * @member {boolean} hasCatalog
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.hasCatalog = false;

    /**
     * ColumnsRequest hasSchemaPattern.
     * @member {boolean} hasSchemaPattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.hasSchemaPattern = false;

    /**
     * ColumnsRequest hasTableNamePattern.
     * @member {boolean} hasTableNamePattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.hasTableNamePattern = false;

    /**
     * ColumnsRequest hasColumnNamePattern.
     * @member {boolean} hasColumnNamePattern
     * @memberof ColumnsRequest
     * @instance
     */
    ColumnsRequest.prototype.hasColumnNamePattern = false;

    /**
     * Creates a new ColumnsRequest instance using the specified properties.
     * @function create
     * @memberof ColumnsRequest
     * @static
     * @param {IColumnsRequest=} [properties] Properties to set
     * @returns {ColumnsRequest} ColumnsRequest instance
     */
    ColumnsRequest.create = function create(properties) {
        return new ColumnsRequest(properties);
    };

    /**
     * Encodes the specified ColumnsRequest message. Does not implicitly {@link ColumnsRequest.verify|verify} messages.
     * @function encode
     * @memberof ColumnsRequest
     * @static
     * @param {IColumnsRequest} message ColumnsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.catalog);
        if (message.schemaPattern != null && Object.hasOwnProperty.call(message, "schemaPattern"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.schemaPattern);
        if (message.tableNamePattern != null && Object.hasOwnProperty.call(message, "tableNamePattern"))
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.tableNamePattern);
        if (message.columnNamePattern != null && Object.hasOwnProperty.call(message, "columnNamePattern"))
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.columnNamePattern);
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.connectionId);
        if (message.hasCatalog != null && Object.hasOwnProperty.call(message, "hasCatalog"))
            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasCatalog);
        if (message.hasSchemaPattern != null && Object.hasOwnProperty.call(message, "hasSchemaPattern"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasSchemaPattern);
        if (message.hasTableNamePattern != null && Object.hasOwnProperty.call(message, "hasTableNamePattern"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasTableNamePattern);
        if (message.hasColumnNamePattern != null && Object.hasOwnProperty.call(message, "hasColumnNamePattern"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.hasColumnNamePattern);
        return writer;
    };

    /**
     * Encodes the specified ColumnsRequest message, length delimited. Does not implicitly {@link ColumnsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ColumnsRequest
     * @static
     * @param {IColumnsRequest} message ColumnsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ColumnsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ColumnsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ColumnsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ColumnsRequest} ColumnsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnsRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ColumnsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.catalog = reader.string();
                    break;
                }
            case 2: {
                    message.schemaPattern = reader.string();
                    break;
                }
            case 3: {
                    message.tableNamePattern = reader.string();
                    break;
                }
            case 4: {
                    message.columnNamePattern = reader.string();
                    break;
                }
            case 5: {
                    message.connectionId = reader.string();
                    break;
                }
            case 6: {
                    message.hasCatalog = reader.bool();
                    break;
                }
            case 7: {
                    message.hasSchemaPattern = reader.bool();
                    break;
                }
            case 8: {
                    message.hasTableNamePattern = reader.bool();
                    break;
                }
            case 9: {
                    message.hasColumnNamePattern = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ColumnsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ColumnsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ColumnsRequest} ColumnsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ColumnsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ColumnsRequest message.
     * @function verify
     * @memberof ColumnsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ColumnsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            if (!$util.isString(message.catalog))
                return "catalog: string expected";
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            if (!$util.isString(message.schemaPattern))
                return "schemaPattern: string expected";
        if (message.tableNamePattern != null && message.hasOwnProperty("tableNamePattern"))
            if (!$util.isString(message.tableNamePattern))
                return "tableNamePattern: string expected";
        if (message.columnNamePattern != null && message.hasOwnProperty("columnNamePattern"))
            if (!$util.isString(message.columnNamePattern))
                return "columnNamePattern: string expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            if (typeof message.hasCatalog !== "boolean")
                return "hasCatalog: boolean expected";
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            if (typeof message.hasSchemaPattern !== "boolean")
                return "hasSchemaPattern: boolean expected";
        if (message.hasTableNamePattern != null && message.hasOwnProperty("hasTableNamePattern"))
            if (typeof message.hasTableNamePattern !== "boolean")
                return "hasTableNamePattern: boolean expected";
        if (message.hasColumnNamePattern != null && message.hasOwnProperty("hasColumnNamePattern"))
            if (typeof message.hasColumnNamePattern !== "boolean")
                return "hasColumnNamePattern: boolean expected";
        return null;
    };

    /**
     * Creates a ColumnsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ColumnsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ColumnsRequest} ColumnsRequest
     */
    ColumnsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ColumnsRequest)
            return object;
        let message = new $root.ColumnsRequest();
        if (object.catalog != null)
            message.catalog = String(object.catalog);
        if (object.schemaPattern != null)
            message.schemaPattern = String(object.schemaPattern);
        if (object.tableNamePattern != null)
            message.tableNamePattern = String(object.tableNamePattern);
        if (object.columnNamePattern != null)
            message.columnNamePattern = String(object.columnNamePattern);
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.hasCatalog != null)
            message.hasCatalog = Boolean(object.hasCatalog);
        if (object.hasSchemaPattern != null)
            message.hasSchemaPattern = Boolean(object.hasSchemaPattern);
        if (object.hasTableNamePattern != null)
            message.hasTableNamePattern = Boolean(object.hasTableNamePattern);
        if (object.hasColumnNamePattern != null)
            message.hasColumnNamePattern = Boolean(object.hasColumnNamePattern);
        return message;
    };

    /**
     * Creates a plain object from a ColumnsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ColumnsRequest
     * @static
     * @param {ColumnsRequest} message ColumnsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ColumnsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.catalog = "";
            object.schemaPattern = "";
            object.tableNamePattern = "";
            object.columnNamePattern = "";
            object.connectionId = "";
            object.hasCatalog = false;
            object.hasSchemaPattern = false;
            object.hasTableNamePattern = false;
            object.hasColumnNamePattern = false;
        }
        if (message.catalog != null && message.hasOwnProperty("catalog"))
            object.catalog = message.catalog;
        if (message.schemaPattern != null && message.hasOwnProperty("schemaPattern"))
            object.schemaPattern = message.schemaPattern;
        if (message.tableNamePattern != null && message.hasOwnProperty("tableNamePattern"))
            object.tableNamePattern = message.tableNamePattern;
        if (message.columnNamePattern != null && message.hasOwnProperty("columnNamePattern"))
            object.columnNamePattern = message.columnNamePattern;
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.hasCatalog != null && message.hasOwnProperty("hasCatalog"))
            object.hasCatalog = message.hasCatalog;
        if (message.hasSchemaPattern != null && message.hasOwnProperty("hasSchemaPattern"))
            object.hasSchemaPattern = message.hasSchemaPattern;
        if (message.hasTableNamePattern != null && message.hasOwnProperty("hasTableNamePattern"))
            object.hasTableNamePattern = message.hasTableNamePattern;
        if (message.hasColumnNamePattern != null && message.hasOwnProperty("hasColumnNamePattern"))
            object.hasColumnNamePattern = message.hasColumnNamePattern;
        return object;
    };

    /**
     * Converts this ColumnsRequest to JSON.
     * @function toJSON
     * @memberof ColumnsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ColumnsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ColumnsRequest
     * @function getTypeUrl
     * @memberof ColumnsRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ColumnsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ColumnsRequest";
    };

    return ColumnsRequest;
})();

export const TypeInfoRequest = $root.TypeInfoRequest = (() => {

    /**
     * Properties of a TypeInfoRequest.
     * @interface ITypeInfoRequest
     * @property {string|null} [connectionId] TypeInfoRequest connectionId
     */

    /**
     * Constructs a new TypeInfoRequest.
     * @classdesc Represents a TypeInfoRequest.
     * @implements ITypeInfoRequest
     * @constructor
     * @param {ITypeInfoRequest=} [properties] Properties to set
     */
    function TypeInfoRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TypeInfoRequest connectionId.
     * @member {string} connectionId
     * @memberof TypeInfoRequest
     * @instance
     */
    TypeInfoRequest.prototype.connectionId = "";

    /**
     * Creates a new TypeInfoRequest instance using the specified properties.
     * @function create
     * @memberof TypeInfoRequest
     * @static
     * @param {ITypeInfoRequest=} [properties] Properties to set
     * @returns {TypeInfoRequest} TypeInfoRequest instance
     */
    TypeInfoRequest.create = function create(properties) {
        return new TypeInfoRequest(properties);
    };

    /**
     * Encodes the specified TypeInfoRequest message. Does not implicitly {@link TypeInfoRequest.verify|verify} messages.
     * @function encode
     * @memberof TypeInfoRequest
     * @static
     * @param {ITypeInfoRequest} message TypeInfoRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypeInfoRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified TypeInfoRequest message, length delimited. Does not implicitly {@link TypeInfoRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TypeInfoRequest
     * @static
     * @param {ITypeInfoRequest} message TypeInfoRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TypeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TypeInfoRequest message from the specified reader or buffer.
     * @function decode
     * @memberof TypeInfoRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TypeInfoRequest} TypeInfoRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypeInfoRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TypeInfoRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TypeInfoRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TypeInfoRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TypeInfoRequest} TypeInfoRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TypeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TypeInfoRequest message.
     * @function verify
     * @memberof TypeInfoRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TypeInfoRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a TypeInfoRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TypeInfoRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TypeInfoRequest} TypeInfoRequest
     */
    TypeInfoRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.TypeInfoRequest)
            return object;
        let message = new $root.TypeInfoRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a TypeInfoRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TypeInfoRequest
     * @static
     * @param {TypeInfoRequest} message TypeInfoRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TypeInfoRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this TypeInfoRequest to JSON.
     * @function toJSON
     * @memberof TypeInfoRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TypeInfoRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TypeInfoRequest
     * @function getTypeUrl
     * @memberof TypeInfoRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TypeInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TypeInfoRequest";
    };

    return TypeInfoRequest;
})();

export const PrepareAndExecuteRequest = $root.PrepareAndExecuteRequest = (() => {

    /**
     * Properties of a PrepareAndExecuteRequest.
     * @interface IPrepareAndExecuteRequest
     * @property {string|null} [connectionId] PrepareAndExecuteRequest connectionId
     * @property {string|null} [sql] PrepareAndExecuteRequest sql
     * @property {number|Long|null} [maxRowCount] PrepareAndExecuteRequest maxRowCount
     * @property {number|null} [statementId] PrepareAndExecuteRequest statementId
     * @property {number|Long|null} [maxRowsTotal] PrepareAndExecuteRequest maxRowsTotal
     * @property {number|null} [firstFrameMaxSize] PrepareAndExecuteRequest firstFrameMaxSize
     */

    /**
     * Constructs a new PrepareAndExecuteRequest.
     * @classdesc Represents a PrepareAndExecuteRequest.
     * @implements IPrepareAndExecuteRequest
     * @constructor
     * @param {IPrepareAndExecuteRequest=} [properties] Properties to set
     */
    function PrepareAndExecuteRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrepareAndExecuteRequest connectionId.
     * @member {string} connectionId
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.connectionId = "";

    /**
     * PrepareAndExecuteRequest sql.
     * @member {string} sql
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.sql = "";

    /**
     * PrepareAndExecuteRequest maxRowCount.
     * @member {number|Long} maxRowCount
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.maxRowCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * PrepareAndExecuteRequest statementId.
     * @member {number} statementId
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.statementId = 0;

    /**
     * PrepareAndExecuteRequest maxRowsTotal.
     * @member {number|Long} maxRowsTotal
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.maxRowsTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * PrepareAndExecuteRequest firstFrameMaxSize.
     * @member {number} firstFrameMaxSize
     * @memberof PrepareAndExecuteRequest
     * @instance
     */
    PrepareAndExecuteRequest.prototype.firstFrameMaxSize = 0;

    /**
     * Creates a new PrepareAndExecuteRequest instance using the specified properties.
     * @function create
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {IPrepareAndExecuteRequest=} [properties] Properties to set
     * @returns {PrepareAndExecuteRequest} PrepareAndExecuteRequest instance
     */
    PrepareAndExecuteRequest.create = function create(properties) {
        return new PrepareAndExecuteRequest(properties);
    };

    /**
     * Encodes the specified PrepareAndExecuteRequest message. Does not implicitly {@link PrepareAndExecuteRequest.verify|verify} messages.
     * @function encode
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {IPrepareAndExecuteRequest} message PrepareAndExecuteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareAndExecuteRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sql);
        if (message.maxRowCount != null && Object.hasOwnProperty.call(message, "maxRowCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.maxRowCount);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.statementId);
        if (message.maxRowsTotal != null && Object.hasOwnProperty.call(message, "maxRowsTotal"))
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.maxRowsTotal);
        if (message.firstFrameMaxSize != null && Object.hasOwnProperty.call(message, "firstFrameMaxSize"))
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.firstFrameMaxSize);
        return writer;
    };

    /**
     * Encodes the specified PrepareAndExecuteRequest message, length delimited. Does not implicitly {@link PrepareAndExecuteRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {IPrepareAndExecuteRequest} message PrepareAndExecuteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareAndExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrepareAndExecuteRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrepareAndExecuteRequest} PrepareAndExecuteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareAndExecuteRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrepareAndExecuteRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.sql = reader.string();
                    break;
                }
            case 3: {
                    message.maxRowCount = reader.uint64();
                    break;
                }
            case 4: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 5: {
                    message.maxRowsTotal = reader.int64();
                    break;
                }
            case 6: {
                    message.firstFrameMaxSize = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrepareAndExecuteRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrepareAndExecuteRequest} PrepareAndExecuteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareAndExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrepareAndExecuteRequest message.
     * @function verify
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrepareAndExecuteRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.sql != null && message.hasOwnProperty("sql"))
            if (!$util.isString(message.sql))
                return "sql: string expected";
        if (message.maxRowCount != null && message.hasOwnProperty("maxRowCount"))
            if (!$util.isInteger(message.maxRowCount) && !(message.maxRowCount && $util.isInteger(message.maxRowCount.low) && $util.isInteger(message.maxRowCount.high)))
                return "maxRowCount: integer|Long expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.maxRowsTotal != null && message.hasOwnProperty("maxRowsTotal"))
            if (!$util.isInteger(message.maxRowsTotal) && !(message.maxRowsTotal && $util.isInteger(message.maxRowsTotal.low) && $util.isInteger(message.maxRowsTotal.high)))
                return "maxRowsTotal: integer|Long expected";
        if (message.firstFrameMaxSize != null && message.hasOwnProperty("firstFrameMaxSize"))
            if (!$util.isInteger(message.firstFrameMaxSize))
                return "firstFrameMaxSize: integer expected";
        return null;
    };

    /**
     * Creates a PrepareAndExecuteRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrepareAndExecuteRequest} PrepareAndExecuteRequest
     */
    PrepareAndExecuteRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PrepareAndExecuteRequest)
            return object;
        let message = new $root.PrepareAndExecuteRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.sql != null)
            message.sql = String(object.sql);
        if (object.maxRowCount != null)
            if ($util.Long)
                (message.maxRowCount = $util.Long.fromValue(object.maxRowCount)).unsigned = true;
            else if (typeof object.maxRowCount === "string")
                message.maxRowCount = parseInt(object.maxRowCount, 10);
            else if (typeof object.maxRowCount === "number")
                message.maxRowCount = object.maxRowCount;
            else if (typeof object.maxRowCount === "object")
                message.maxRowCount = new $util.LongBits(object.maxRowCount.low >>> 0, object.maxRowCount.high >>> 0).toNumber(true);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.maxRowsTotal != null)
            if ($util.Long)
                (message.maxRowsTotal = $util.Long.fromValue(object.maxRowsTotal)).unsigned = false;
            else if (typeof object.maxRowsTotal === "string")
                message.maxRowsTotal = parseInt(object.maxRowsTotal, 10);
            else if (typeof object.maxRowsTotal === "number")
                message.maxRowsTotal = object.maxRowsTotal;
            else if (typeof object.maxRowsTotal === "object")
                message.maxRowsTotal = new $util.LongBits(object.maxRowsTotal.low >>> 0, object.maxRowsTotal.high >>> 0).toNumber();
        if (object.firstFrameMaxSize != null)
            message.firstFrameMaxSize = object.firstFrameMaxSize | 0;
        return message;
    };

    /**
     * Creates a plain object from a PrepareAndExecuteRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {PrepareAndExecuteRequest} message PrepareAndExecuteRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrepareAndExecuteRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.sql = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxRowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxRowCount = options.longs === String ? "0" : 0;
            object.statementId = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.maxRowsTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxRowsTotal = options.longs === String ? "0" : 0;
            object.firstFrameMaxSize = 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.sql != null && message.hasOwnProperty("sql"))
            object.sql = message.sql;
        if (message.maxRowCount != null && message.hasOwnProperty("maxRowCount"))
            if (typeof message.maxRowCount === "number")
                object.maxRowCount = options.longs === String ? String(message.maxRowCount) : message.maxRowCount;
            else
                object.maxRowCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxRowCount) : options.longs === Number ? new $util.LongBits(message.maxRowCount.low >>> 0, message.maxRowCount.high >>> 0).toNumber(true) : message.maxRowCount;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.maxRowsTotal != null && message.hasOwnProperty("maxRowsTotal"))
            if (typeof message.maxRowsTotal === "number")
                object.maxRowsTotal = options.longs === String ? String(message.maxRowsTotal) : message.maxRowsTotal;
            else
                object.maxRowsTotal = options.longs === String ? $util.Long.prototype.toString.call(message.maxRowsTotal) : options.longs === Number ? new $util.LongBits(message.maxRowsTotal.low >>> 0, message.maxRowsTotal.high >>> 0).toNumber() : message.maxRowsTotal;
        if (message.firstFrameMaxSize != null && message.hasOwnProperty("firstFrameMaxSize"))
            object.firstFrameMaxSize = message.firstFrameMaxSize;
        return object;
    };

    /**
     * Converts this PrepareAndExecuteRequest to JSON.
     * @function toJSON
     * @memberof PrepareAndExecuteRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrepareAndExecuteRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PrepareAndExecuteRequest
     * @function getTypeUrl
     * @memberof PrepareAndExecuteRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PrepareAndExecuteRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PrepareAndExecuteRequest";
    };

    return PrepareAndExecuteRequest;
})();

export const PrepareRequest = $root.PrepareRequest = (() => {

    /**
     * Properties of a PrepareRequest.
     * @interface IPrepareRequest
     * @property {string|null} [connectionId] PrepareRequest connectionId
     * @property {string|null} [sql] PrepareRequest sql
     * @property {number|Long|null} [maxRowCount] PrepareRequest maxRowCount
     * @property {number|Long|null} [maxRowsTotal] PrepareRequest maxRowsTotal
     */

    /**
     * Constructs a new PrepareRequest.
     * @classdesc Represents a PrepareRequest.
     * @implements IPrepareRequest
     * @constructor
     * @param {IPrepareRequest=} [properties] Properties to set
     */
    function PrepareRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrepareRequest connectionId.
     * @member {string} connectionId
     * @memberof PrepareRequest
     * @instance
     */
    PrepareRequest.prototype.connectionId = "";

    /**
     * PrepareRequest sql.
     * @member {string} sql
     * @memberof PrepareRequest
     * @instance
     */
    PrepareRequest.prototype.sql = "";

    /**
     * PrepareRequest maxRowCount.
     * @member {number|Long} maxRowCount
     * @memberof PrepareRequest
     * @instance
     */
    PrepareRequest.prototype.maxRowCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * PrepareRequest maxRowsTotal.
     * @member {number|Long} maxRowsTotal
     * @memberof PrepareRequest
     * @instance
     */
    PrepareRequest.prototype.maxRowsTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

    /**
     * Creates a new PrepareRequest instance using the specified properties.
     * @function create
     * @memberof PrepareRequest
     * @static
     * @param {IPrepareRequest=} [properties] Properties to set
     * @returns {PrepareRequest} PrepareRequest instance
     */
    PrepareRequest.create = function create(properties) {
        return new PrepareRequest(properties);
    };

    /**
     * Encodes the specified PrepareRequest message. Does not implicitly {@link PrepareRequest.verify|verify} messages.
     * @function encode
     * @memberof PrepareRequest
     * @static
     * @param {IPrepareRequest} message PrepareRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.sql != null && Object.hasOwnProperty.call(message, "sql"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sql);
        if (message.maxRowCount != null && Object.hasOwnProperty.call(message, "maxRowCount"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.maxRowCount);
        if (message.maxRowsTotal != null && Object.hasOwnProperty.call(message, "maxRowsTotal"))
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxRowsTotal);
        return writer;
    };

    /**
     * Encodes the specified PrepareRequest message, length delimited. Does not implicitly {@link PrepareRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrepareRequest
     * @static
     * @param {IPrepareRequest} message PrepareRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrepareRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PrepareRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrepareRequest} PrepareRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrepareRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.sql = reader.string();
                    break;
                }
            case 3: {
                    message.maxRowCount = reader.uint64();
                    break;
                }
            case 4: {
                    message.maxRowsTotal = reader.int64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrepareRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrepareRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrepareRequest} PrepareRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrepareRequest message.
     * @function verify
     * @memberof PrepareRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrepareRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.sql != null && message.hasOwnProperty("sql"))
            if (!$util.isString(message.sql))
                return "sql: string expected";
        if (message.maxRowCount != null && message.hasOwnProperty("maxRowCount"))
            if (!$util.isInteger(message.maxRowCount) && !(message.maxRowCount && $util.isInteger(message.maxRowCount.low) && $util.isInteger(message.maxRowCount.high)))
                return "maxRowCount: integer|Long expected";
        if (message.maxRowsTotal != null && message.hasOwnProperty("maxRowsTotal"))
            if (!$util.isInteger(message.maxRowsTotal) && !(message.maxRowsTotal && $util.isInteger(message.maxRowsTotal.low) && $util.isInteger(message.maxRowsTotal.high)))
                return "maxRowsTotal: integer|Long expected";
        return null;
    };

    /**
     * Creates a PrepareRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrepareRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrepareRequest} PrepareRequest
     */
    PrepareRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PrepareRequest)
            return object;
        let message = new $root.PrepareRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.sql != null)
            message.sql = String(object.sql);
        if (object.maxRowCount != null)
            if ($util.Long)
                (message.maxRowCount = $util.Long.fromValue(object.maxRowCount)).unsigned = true;
            else if (typeof object.maxRowCount === "string")
                message.maxRowCount = parseInt(object.maxRowCount, 10);
            else if (typeof object.maxRowCount === "number")
                message.maxRowCount = object.maxRowCount;
            else if (typeof object.maxRowCount === "object")
                message.maxRowCount = new $util.LongBits(object.maxRowCount.low >>> 0, object.maxRowCount.high >>> 0).toNumber(true);
        if (object.maxRowsTotal != null)
            if ($util.Long)
                (message.maxRowsTotal = $util.Long.fromValue(object.maxRowsTotal)).unsigned = false;
            else if (typeof object.maxRowsTotal === "string")
                message.maxRowsTotal = parseInt(object.maxRowsTotal, 10);
            else if (typeof object.maxRowsTotal === "number")
                message.maxRowsTotal = object.maxRowsTotal;
            else if (typeof object.maxRowsTotal === "object")
                message.maxRowsTotal = new $util.LongBits(object.maxRowsTotal.low >>> 0, object.maxRowsTotal.high >>> 0).toNumber();
        return message;
    };

    /**
     * Creates a plain object from a PrepareRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrepareRequest
     * @static
     * @param {PrepareRequest} message PrepareRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrepareRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.sql = "";
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.maxRowCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxRowCount = options.longs === String ? "0" : 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, false);
                object.maxRowsTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.maxRowsTotal = options.longs === String ? "0" : 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.sql != null && message.hasOwnProperty("sql"))
            object.sql = message.sql;
        if (message.maxRowCount != null && message.hasOwnProperty("maxRowCount"))
            if (typeof message.maxRowCount === "number")
                object.maxRowCount = options.longs === String ? String(message.maxRowCount) : message.maxRowCount;
            else
                object.maxRowCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxRowCount) : options.longs === Number ? new $util.LongBits(message.maxRowCount.low >>> 0, message.maxRowCount.high >>> 0).toNumber(true) : message.maxRowCount;
        if (message.maxRowsTotal != null && message.hasOwnProperty("maxRowsTotal"))
            if (typeof message.maxRowsTotal === "number")
                object.maxRowsTotal = options.longs === String ? String(message.maxRowsTotal) : message.maxRowsTotal;
            else
                object.maxRowsTotal = options.longs === String ? $util.Long.prototype.toString.call(message.maxRowsTotal) : options.longs === Number ? new $util.LongBits(message.maxRowsTotal.low >>> 0, message.maxRowsTotal.high >>> 0).toNumber() : message.maxRowsTotal;
        return object;
    };

    /**
     * Converts this PrepareRequest to JSON.
     * @function toJSON
     * @memberof PrepareRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrepareRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PrepareRequest
     * @function getTypeUrl
     * @memberof PrepareRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PrepareRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PrepareRequest";
    };

    return PrepareRequest;
})();

export const FetchRequest = $root.FetchRequest = (() => {

    /**
     * Properties of a FetchRequest.
     * @interface IFetchRequest
     * @property {string|null} [connectionId] FetchRequest connectionId
     * @property {number|null} [statementId] FetchRequest statementId
     * @property {number|Long|null} [offset] FetchRequest offset
     * @property {number|null} [fetchMaxRowCount] FetchRequest fetchMaxRowCount
     * @property {number|null} [frameMaxSize] FetchRequest frameMaxSize
     */

    /**
     * Constructs a new FetchRequest.
     * @classdesc Represents a FetchRequest.
     * @implements IFetchRequest
     * @constructor
     * @param {IFetchRequest=} [properties] Properties to set
     */
    function FetchRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * FetchRequest connectionId.
     * @member {string} connectionId
     * @memberof FetchRequest
     * @instance
     */
    FetchRequest.prototype.connectionId = "";

    /**
     * FetchRequest statementId.
     * @member {number} statementId
     * @memberof FetchRequest
     * @instance
     */
    FetchRequest.prototype.statementId = 0;

    /**
     * FetchRequest offset.
     * @member {number|Long} offset
     * @memberof FetchRequest
     * @instance
     */
    FetchRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * FetchRequest fetchMaxRowCount.
     * @member {number} fetchMaxRowCount
     * @memberof FetchRequest
     * @instance
     */
    FetchRequest.prototype.fetchMaxRowCount = 0;

    /**
     * FetchRequest frameMaxSize.
     * @member {number} frameMaxSize
     * @memberof FetchRequest
     * @instance
     */
    FetchRequest.prototype.frameMaxSize = 0;

    /**
     * Creates a new FetchRequest instance using the specified properties.
     * @function create
     * @memberof FetchRequest
     * @static
     * @param {IFetchRequest=} [properties] Properties to set
     * @returns {FetchRequest} FetchRequest instance
     */
    FetchRequest.create = function create(properties) {
        return new FetchRequest(properties);
    };

    /**
     * Encodes the specified FetchRequest message. Does not implicitly {@link FetchRequest.verify|verify} messages.
     * @function encode
     * @memberof FetchRequest
     * @static
     * @param {IFetchRequest} message FetchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FetchRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.offset);
        if (message.fetchMaxRowCount != null && Object.hasOwnProperty.call(message, "fetchMaxRowCount"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.fetchMaxRowCount);
        if (message.frameMaxSize != null && Object.hasOwnProperty.call(message, "frameMaxSize"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.frameMaxSize);
        return writer;
    };

    /**
     * Encodes the specified FetchRequest message, length delimited. Does not implicitly {@link FetchRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof FetchRequest
     * @static
     * @param {IFetchRequest} message FetchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    FetchRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a FetchRequest message from the specified reader or buffer.
     * @function decode
     * @memberof FetchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {FetchRequest} FetchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FetchRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.FetchRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    message.offset = reader.uint64();
                    break;
                }
            case 4: {
                    message.fetchMaxRowCount = reader.uint32();
                    break;
                }
            case 5: {
                    message.frameMaxSize = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a FetchRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof FetchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {FetchRequest} FetchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    FetchRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a FetchRequest message.
     * @function verify
     * @memberof FetchRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    FetchRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                return "offset: integer|Long expected";
        if (message.fetchMaxRowCount != null && message.hasOwnProperty("fetchMaxRowCount"))
            if (!$util.isInteger(message.fetchMaxRowCount))
                return "fetchMaxRowCount: integer expected";
        if (message.frameMaxSize != null && message.hasOwnProperty("frameMaxSize"))
            if (!$util.isInteger(message.frameMaxSize))
                return "frameMaxSize: integer expected";
        return null;
    };

    /**
     * Creates a FetchRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof FetchRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {FetchRequest} FetchRequest
     */
    FetchRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.FetchRequest)
            return object;
        let message = new $root.FetchRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.offset != null)
            if ($util.Long)
                (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
            else if (typeof object.offset === "string")
                message.offset = parseInt(object.offset, 10);
            else if (typeof object.offset === "number")
                message.offset = object.offset;
            else if (typeof object.offset === "object")
                message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
        if (object.fetchMaxRowCount != null)
            message.fetchMaxRowCount = object.fetchMaxRowCount >>> 0;
        if (object.frameMaxSize != null)
            message.frameMaxSize = object.frameMaxSize | 0;
        return message;
    };

    /**
     * Creates a plain object from a FetchRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof FetchRequest
     * @static
     * @param {FetchRequest} message FetchRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    FetchRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.offset = options.longs === String ? "0" : 0;
            object.fetchMaxRowCount = 0;
            object.frameMaxSize = 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (typeof message.offset === "number")
                object.offset = options.longs === String ? String(message.offset) : message.offset;
            else
                object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
        if (message.fetchMaxRowCount != null && message.hasOwnProperty("fetchMaxRowCount"))
            object.fetchMaxRowCount = message.fetchMaxRowCount;
        if (message.frameMaxSize != null && message.hasOwnProperty("frameMaxSize"))
            object.frameMaxSize = message.frameMaxSize;
        return object;
    };

    /**
     * Converts this FetchRequest to JSON.
     * @function toJSON
     * @memberof FetchRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    FetchRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for FetchRequest
     * @function getTypeUrl
     * @memberof FetchRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    FetchRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/FetchRequest";
    };

    return FetchRequest;
})();

export const CreateStatementRequest = $root.CreateStatementRequest = (() => {

    /**
     * Properties of a CreateStatementRequest.
     * @interface ICreateStatementRequest
     * @property {string|null} [connectionId] CreateStatementRequest connectionId
     */

    /**
     * Constructs a new CreateStatementRequest.
     * @classdesc Represents a CreateStatementRequest.
     * @implements ICreateStatementRequest
     * @constructor
     * @param {ICreateStatementRequest=} [properties] Properties to set
     */
    function CreateStatementRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CreateStatementRequest connectionId.
     * @member {string} connectionId
     * @memberof CreateStatementRequest
     * @instance
     */
    CreateStatementRequest.prototype.connectionId = "";

    /**
     * Creates a new CreateStatementRequest instance using the specified properties.
     * @function create
     * @memberof CreateStatementRequest
     * @static
     * @param {ICreateStatementRequest=} [properties] Properties to set
     * @returns {CreateStatementRequest} CreateStatementRequest instance
     */
    CreateStatementRequest.create = function create(properties) {
        return new CreateStatementRequest(properties);
    };

    /**
     * Encodes the specified CreateStatementRequest message. Does not implicitly {@link CreateStatementRequest.verify|verify} messages.
     * @function encode
     * @memberof CreateStatementRequest
     * @static
     * @param {ICreateStatementRequest} message CreateStatementRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateStatementRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified CreateStatementRequest message, length delimited. Does not implicitly {@link CreateStatementRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CreateStatementRequest
     * @static
     * @param {ICreateStatementRequest} message CreateStatementRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CreateStatementRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CreateStatementRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CreateStatementRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CreateStatementRequest} CreateStatementRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateStatementRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateStatementRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CreateStatementRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CreateStatementRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CreateStatementRequest} CreateStatementRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CreateStatementRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CreateStatementRequest message.
     * @function verify
     * @memberof CreateStatementRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CreateStatementRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a CreateStatementRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CreateStatementRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CreateStatementRequest} CreateStatementRequest
     */
    CreateStatementRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CreateStatementRequest)
            return object;
        let message = new $root.CreateStatementRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a CreateStatementRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CreateStatementRequest
     * @static
     * @param {CreateStatementRequest} message CreateStatementRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CreateStatementRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this CreateStatementRequest to JSON.
     * @function toJSON
     * @memberof CreateStatementRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CreateStatementRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CreateStatementRequest
     * @function getTypeUrl
     * @memberof CreateStatementRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CreateStatementRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CreateStatementRequest";
    };

    return CreateStatementRequest;
})();

export const CloseStatementRequest = $root.CloseStatementRequest = (() => {

    /**
     * Properties of a CloseStatementRequest.
     * @interface ICloseStatementRequest
     * @property {string|null} [connectionId] CloseStatementRequest connectionId
     * @property {number|null} [statementId] CloseStatementRequest statementId
     */

    /**
     * Constructs a new CloseStatementRequest.
     * @classdesc Represents a CloseStatementRequest.
     * @implements ICloseStatementRequest
     * @constructor
     * @param {ICloseStatementRequest=} [properties] Properties to set
     */
    function CloseStatementRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CloseStatementRequest connectionId.
     * @member {string} connectionId
     * @memberof CloseStatementRequest
     * @instance
     */
    CloseStatementRequest.prototype.connectionId = "";

    /**
     * CloseStatementRequest statementId.
     * @member {number} statementId
     * @memberof CloseStatementRequest
     * @instance
     */
    CloseStatementRequest.prototype.statementId = 0;

    /**
     * Creates a new CloseStatementRequest instance using the specified properties.
     * @function create
     * @memberof CloseStatementRequest
     * @static
     * @param {ICloseStatementRequest=} [properties] Properties to set
     * @returns {CloseStatementRequest} CloseStatementRequest instance
     */
    CloseStatementRequest.create = function create(properties) {
        return new CloseStatementRequest(properties);
    };

    /**
     * Encodes the specified CloseStatementRequest message. Does not implicitly {@link CloseStatementRequest.verify|verify} messages.
     * @function encode
     * @memberof CloseStatementRequest
     * @static
     * @param {ICloseStatementRequest} message CloseStatementRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseStatementRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        return writer;
    };

    /**
     * Encodes the specified CloseStatementRequest message, length delimited. Does not implicitly {@link CloseStatementRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CloseStatementRequest
     * @static
     * @param {ICloseStatementRequest} message CloseStatementRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseStatementRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CloseStatementRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CloseStatementRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CloseStatementRequest} CloseStatementRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseStatementRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CloseStatementRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CloseStatementRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CloseStatementRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CloseStatementRequest} CloseStatementRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseStatementRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CloseStatementRequest message.
     * @function verify
     * @memberof CloseStatementRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CloseStatementRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        return null;
    };

    /**
     * Creates a CloseStatementRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CloseStatementRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CloseStatementRequest} CloseStatementRequest
     */
    CloseStatementRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CloseStatementRequest)
            return object;
        let message = new $root.CloseStatementRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a CloseStatementRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CloseStatementRequest
     * @static
     * @param {CloseStatementRequest} message CloseStatementRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CloseStatementRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        return object;
    };

    /**
     * Converts this CloseStatementRequest to JSON.
     * @function toJSON
     * @memberof CloseStatementRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CloseStatementRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CloseStatementRequest
     * @function getTypeUrl
     * @memberof CloseStatementRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CloseStatementRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CloseStatementRequest";
    };

    return CloseStatementRequest;
})();

export const OpenConnectionRequest = $root.OpenConnectionRequest = (() => {

    /**
     * Properties of an OpenConnectionRequest.
     * @interface IOpenConnectionRequest
     * @property {string|null} [connectionId] OpenConnectionRequest connectionId
     * @property {Object.<string,string>|null} [info] OpenConnectionRequest info
     */

    /**
     * Constructs a new OpenConnectionRequest.
     * @classdesc Represents an OpenConnectionRequest.
     * @implements IOpenConnectionRequest
     * @constructor
     * @param {IOpenConnectionRequest=} [properties] Properties to set
     */
    function OpenConnectionRequest(properties) {
        this.info = {};
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * OpenConnectionRequest connectionId.
     * @member {string} connectionId
     * @memberof OpenConnectionRequest
     * @instance
     */
    OpenConnectionRequest.prototype.connectionId = "";

    /**
     * OpenConnectionRequest info.
     * @member {Object.<string,string>} info
     * @memberof OpenConnectionRequest
     * @instance
     */
    OpenConnectionRequest.prototype.info = $util.emptyObject;

    /**
     * Creates a new OpenConnectionRequest instance using the specified properties.
     * @function create
     * @memberof OpenConnectionRequest
     * @static
     * @param {IOpenConnectionRequest=} [properties] Properties to set
     * @returns {OpenConnectionRequest} OpenConnectionRequest instance
     */
    OpenConnectionRequest.create = function create(properties) {
        return new OpenConnectionRequest(properties);
    };

    /**
     * Encodes the specified OpenConnectionRequest message. Does not implicitly {@link OpenConnectionRequest.verify|verify} messages.
     * @function encode
     * @memberof OpenConnectionRequest
     * @static
     * @param {IOpenConnectionRequest} message OpenConnectionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenConnectionRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.info != null && Object.hasOwnProperty.call(message, "info"))
            for (let keys = Object.keys(message.info), i = 0; i < keys.length; ++i)
                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.info[keys[i]]).ldelim();
        return writer;
    };

    /**
     * Encodes the specified OpenConnectionRequest message, length delimited. Does not implicitly {@link OpenConnectionRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof OpenConnectionRequest
     * @static
     * @param {IOpenConnectionRequest} message OpenConnectionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    OpenConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an OpenConnectionRequest message from the specified reader or buffer.
     * @function decode
     * @memberof OpenConnectionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OpenConnectionRequest} OpenConnectionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenConnectionRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpenConnectionRequest(), key, value;
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    if (message.info === $util.emptyObject)
                        message.info = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                        let tag2 = reader.uint32();
                        switch (tag2 >>> 3) {
                        case 1:
                            key = reader.string();
                            break;
                        case 2:
                            value = reader.string();
                            break;
                        default:
                            reader.skipType(tag2 & 7);
                            break;
                        }
                    }
                    message.info[key] = value;
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an OpenConnectionRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof OpenConnectionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {OpenConnectionRequest} OpenConnectionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OpenConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an OpenConnectionRequest message.
     * @function verify
     * @memberof OpenConnectionRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    OpenConnectionRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.info != null && message.hasOwnProperty("info")) {
            if (!$util.isObject(message.info))
                return "info: object expected";
            let key = Object.keys(message.info);
            for (let i = 0; i < key.length; ++i)
                if (!$util.isString(message.info[key[i]]))
                    return "info: string{k:string} expected";
        }
        return null;
    };

    /**
     * Creates an OpenConnectionRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof OpenConnectionRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {OpenConnectionRequest} OpenConnectionRequest
     */
    OpenConnectionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.OpenConnectionRequest)
            return object;
        let message = new $root.OpenConnectionRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.info) {
            if (typeof object.info !== "object")
                throw TypeError(".OpenConnectionRequest.info: object expected");
            message.info = {};
            for (let keys = Object.keys(object.info), i = 0; i < keys.length; ++i)
                message.info[keys[i]] = String(object.info[keys[i]]);
        }
        return message;
    };

    /**
     * Creates a plain object from an OpenConnectionRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof OpenConnectionRequest
     * @static
     * @param {OpenConnectionRequest} message OpenConnectionRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    OpenConnectionRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.objects || options.defaults)
            object.info = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        let keys2;
        if (message.info && (keys2 = Object.keys(message.info)).length) {
            object.info = {};
            for (let j = 0; j < keys2.length; ++j)
                object.info[keys2[j]] = message.info[keys2[j]];
        }
        return object;
    };

    /**
     * Converts this OpenConnectionRequest to JSON.
     * @function toJSON
     * @memberof OpenConnectionRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    OpenConnectionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for OpenConnectionRequest
     * @function getTypeUrl
     * @memberof OpenConnectionRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    OpenConnectionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/OpenConnectionRequest";
    };

    return OpenConnectionRequest;
})();

export const CloseConnectionRequest = $root.CloseConnectionRequest = (() => {

    /**
     * Properties of a CloseConnectionRequest.
     * @interface ICloseConnectionRequest
     * @property {string|null} [connectionId] CloseConnectionRequest connectionId
     */

    /**
     * Constructs a new CloseConnectionRequest.
     * @classdesc Represents a CloseConnectionRequest.
     * @implements ICloseConnectionRequest
     * @constructor
     * @param {ICloseConnectionRequest=} [properties] Properties to set
     */
    function CloseConnectionRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CloseConnectionRequest connectionId.
     * @member {string} connectionId
     * @memberof CloseConnectionRequest
     * @instance
     */
    CloseConnectionRequest.prototype.connectionId = "";

    /**
     * Creates a new CloseConnectionRequest instance using the specified properties.
     * @function create
     * @memberof CloseConnectionRequest
     * @static
     * @param {ICloseConnectionRequest=} [properties] Properties to set
     * @returns {CloseConnectionRequest} CloseConnectionRequest instance
     */
    CloseConnectionRequest.create = function create(properties) {
        return new CloseConnectionRequest(properties);
    };

    /**
     * Encodes the specified CloseConnectionRequest message. Does not implicitly {@link CloseConnectionRequest.verify|verify} messages.
     * @function encode
     * @memberof CloseConnectionRequest
     * @static
     * @param {ICloseConnectionRequest} message CloseConnectionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseConnectionRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified CloseConnectionRequest message, length delimited. Does not implicitly {@link CloseConnectionRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CloseConnectionRequest
     * @static
     * @param {ICloseConnectionRequest} message CloseConnectionRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CloseConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CloseConnectionRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CloseConnectionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CloseConnectionRequest} CloseConnectionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseConnectionRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CloseConnectionRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CloseConnectionRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CloseConnectionRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CloseConnectionRequest} CloseConnectionRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CloseConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CloseConnectionRequest message.
     * @function verify
     * @memberof CloseConnectionRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CloseConnectionRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a CloseConnectionRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CloseConnectionRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CloseConnectionRequest} CloseConnectionRequest
     */
    CloseConnectionRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CloseConnectionRequest)
            return object;
        let message = new $root.CloseConnectionRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a CloseConnectionRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CloseConnectionRequest
     * @static
     * @param {CloseConnectionRequest} message CloseConnectionRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CloseConnectionRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this CloseConnectionRequest to JSON.
     * @function toJSON
     * @memberof CloseConnectionRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CloseConnectionRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CloseConnectionRequest
     * @function getTypeUrl
     * @memberof CloseConnectionRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CloseConnectionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CloseConnectionRequest";
    };

    return CloseConnectionRequest;
})();

export const ConnectionSyncRequest = $root.ConnectionSyncRequest = (() => {

    /**
     * Properties of a ConnectionSyncRequest.
     * @interface IConnectionSyncRequest
     * @property {string|null} [connectionId] ConnectionSyncRequest connectionId
     * @property {IConnectionProperties|null} [connProps] ConnectionSyncRequest connProps
     */

    /**
     * Constructs a new ConnectionSyncRequest.
     * @classdesc Represents a ConnectionSyncRequest.
     * @implements IConnectionSyncRequest
     * @constructor
     * @param {IConnectionSyncRequest=} [properties] Properties to set
     */
    function ConnectionSyncRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ConnectionSyncRequest connectionId.
     * @member {string} connectionId
     * @memberof ConnectionSyncRequest
     * @instance
     */
    ConnectionSyncRequest.prototype.connectionId = "";

    /**
     * ConnectionSyncRequest connProps.
     * @member {IConnectionProperties|null|undefined} connProps
     * @memberof ConnectionSyncRequest
     * @instance
     */
    ConnectionSyncRequest.prototype.connProps = null;

    /**
     * Creates a new ConnectionSyncRequest instance using the specified properties.
     * @function create
     * @memberof ConnectionSyncRequest
     * @static
     * @param {IConnectionSyncRequest=} [properties] Properties to set
     * @returns {ConnectionSyncRequest} ConnectionSyncRequest instance
     */
    ConnectionSyncRequest.create = function create(properties) {
        return new ConnectionSyncRequest(properties);
    };

    /**
     * Encodes the specified ConnectionSyncRequest message. Does not implicitly {@link ConnectionSyncRequest.verify|verify} messages.
     * @function encode
     * @memberof ConnectionSyncRequest
     * @static
     * @param {IConnectionSyncRequest} message ConnectionSyncRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionSyncRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.connProps != null && Object.hasOwnProperty.call(message, "connProps"))
            $root.ConnectionProperties.encode(message.connProps, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ConnectionSyncRequest message, length delimited. Does not implicitly {@link ConnectionSyncRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ConnectionSyncRequest
     * @static
     * @param {IConnectionSyncRequest} message ConnectionSyncRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ConnectionSyncRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a ConnectionSyncRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ConnectionSyncRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ConnectionSyncRequest} ConnectionSyncRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionSyncRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ConnectionSyncRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.connProps = $root.ConnectionProperties.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a ConnectionSyncRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ConnectionSyncRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ConnectionSyncRequest} ConnectionSyncRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ConnectionSyncRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a ConnectionSyncRequest message.
     * @function verify
     * @memberof ConnectionSyncRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ConnectionSyncRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.connProps != null && message.hasOwnProperty("connProps")) {
            let error = $root.ConnectionProperties.verify(message.connProps);
            if (error)
                return "connProps." + error;
        }
        return null;
    };

    /**
     * Creates a ConnectionSyncRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ConnectionSyncRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ConnectionSyncRequest} ConnectionSyncRequest
     */
    ConnectionSyncRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ConnectionSyncRequest)
            return object;
        let message = new $root.ConnectionSyncRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.connProps != null) {
            if (typeof object.connProps !== "object")
                throw TypeError(".ConnectionSyncRequest.connProps: object expected");
            message.connProps = $root.ConnectionProperties.fromObject(object.connProps);
        }
        return message;
    };

    /**
     * Creates a plain object from a ConnectionSyncRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ConnectionSyncRequest
     * @static
     * @param {ConnectionSyncRequest} message ConnectionSyncRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ConnectionSyncRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.connProps = null;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.connProps != null && message.hasOwnProperty("connProps"))
            object.connProps = $root.ConnectionProperties.toObject(message.connProps, options);
        return object;
    };

    /**
     * Converts this ConnectionSyncRequest to JSON.
     * @function toJSON
     * @memberof ConnectionSyncRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ConnectionSyncRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ConnectionSyncRequest
     * @function getTypeUrl
     * @memberof ConnectionSyncRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ConnectionSyncRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ConnectionSyncRequest";
    };

    return ConnectionSyncRequest;
})();

export const ExecuteRequest = $root.ExecuteRequest = (() => {

    /**
     * Properties of an ExecuteRequest.
     * @interface IExecuteRequest
     * @property {IStatementHandle|null} [statementHandle] ExecuteRequest statementHandle
     * @property {Array.<ITypedValue>|null} [parameterValues] ExecuteRequest parameterValues
     * @property {number|Long|null} [deprecatedFirstFrameMaxSize] ExecuteRequest deprecatedFirstFrameMaxSize
     * @property {boolean|null} [hasParameterValues] ExecuteRequest hasParameterValues
     * @property {number|null} [firstFrameMaxSize] ExecuteRequest firstFrameMaxSize
     */

    /**
     * Constructs a new ExecuteRequest.
     * @classdesc Represents an ExecuteRequest.
     * @implements IExecuteRequest
     * @constructor
     * @param {IExecuteRequest=} [properties] Properties to set
     */
    function ExecuteRequest(properties) {
        this.parameterValues = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExecuteRequest statementHandle.
     * @member {IStatementHandle|null|undefined} statementHandle
     * @memberof ExecuteRequest
     * @instance
     */
    ExecuteRequest.prototype.statementHandle = null;

    /**
     * ExecuteRequest parameterValues.
     * @member {Array.<ITypedValue>} parameterValues
     * @memberof ExecuteRequest
     * @instance
     */
    ExecuteRequest.prototype.parameterValues = $util.emptyArray;

    /**
     * ExecuteRequest deprecatedFirstFrameMaxSize.
     * @member {number|Long} deprecatedFirstFrameMaxSize
     * @memberof ExecuteRequest
     * @instance
     */
    ExecuteRequest.prototype.deprecatedFirstFrameMaxSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * ExecuteRequest hasParameterValues.
     * @member {boolean} hasParameterValues
     * @memberof ExecuteRequest
     * @instance
     */
    ExecuteRequest.prototype.hasParameterValues = false;

    /**
     * ExecuteRequest firstFrameMaxSize.
     * @member {number} firstFrameMaxSize
     * @memberof ExecuteRequest
     * @instance
     */
    ExecuteRequest.prototype.firstFrameMaxSize = 0;

    /**
     * Creates a new ExecuteRequest instance using the specified properties.
     * @function create
     * @memberof ExecuteRequest
     * @static
     * @param {IExecuteRequest=} [properties] Properties to set
     * @returns {ExecuteRequest} ExecuteRequest instance
     */
    ExecuteRequest.create = function create(properties) {
        return new ExecuteRequest(properties);
    };

    /**
     * Encodes the specified ExecuteRequest message. Does not implicitly {@link ExecuteRequest.verify|verify} messages.
     * @function encode
     * @memberof ExecuteRequest
     * @static
     * @param {IExecuteRequest} message ExecuteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.statementHandle != null && Object.hasOwnProperty.call(message, "statementHandle"))
            $root.StatementHandle.encode(message.statementHandle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.parameterValues != null && message.parameterValues.length)
            for (let i = 0; i < message.parameterValues.length; ++i)
                $root.TypedValue.encode(message.parameterValues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.deprecatedFirstFrameMaxSize != null && Object.hasOwnProperty.call(message, "deprecatedFirstFrameMaxSize"))
            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.deprecatedFirstFrameMaxSize);
        if (message.hasParameterValues != null && Object.hasOwnProperty.call(message, "hasParameterValues"))
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.hasParameterValues);
        if (message.firstFrameMaxSize != null && Object.hasOwnProperty.call(message, "firstFrameMaxSize"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.firstFrameMaxSize);
        return writer;
    };

    /**
     * Encodes the specified ExecuteRequest message, length delimited. Does not implicitly {@link ExecuteRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExecuteRequest
     * @static
     * @param {IExecuteRequest} message ExecuteRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExecuteRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ExecuteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExecuteRequest} ExecuteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExecuteRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.statementHandle = $root.StatementHandle.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    if (!(message.parameterValues && message.parameterValues.length))
                        message.parameterValues = [];
                    message.parameterValues.push($root.TypedValue.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    message.deprecatedFirstFrameMaxSize = reader.uint64();
                    break;
                }
            case 4: {
                    message.hasParameterValues = reader.bool();
                    break;
                }
            case 5: {
                    message.firstFrameMaxSize = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExecuteRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExecuteRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExecuteRequest} ExecuteRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExecuteRequest message.
     * @function verify
     * @memberof ExecuteRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExecuteRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.statementHandle != null && message.hasOwnProperty("statementHandle")) {
            let error = $root.StatementHandle.verify(message.statementHandle);
            if (error)
                return "statementHandle." + error;
        }
        if (message.parameterValues != null && message.hasOwnProperty("parameterValues")) {
            if (!Array.isArray(message.parameterValues))
                return "parameterValues: array expected";
            for (let i = 0; i < message.parameterValues.length; ++i) {
                let error = $root.TypedValue.verify(message.parameterValues[i]);
                if (error)
                    return "parameterValues." + error;
            }
        }
        if (message.deprecatedFirstFrameMaxSize != null && message.hasOwnProperty("deprecatedFirstFrameMaxSize"))
            if (!$util.isInteger(message.deprecatedFirstFrameMaxSize) && !(message.deprecatedFirstFrameMaxSize && $util.isInteger(message.deprecatedFirstFrameMaxSize.low) && $util.isInteger(message.deprecatedFirstFrameMaxSize.high)))
                return "deprecatedFirstFrameMaxSize: integer|Long expected";
        if (message.hasParameterValues != null && message.hasOwnProperty("hasParameterValues"))
            if (typeof message.hasParameterValues !== "boolean")
                return "hasParameterValues: boolean expected";
        if (message.firstFrameMaxSize != null && message.hasOwnProperty("firstFrameMaxSize"))
            if (!$util.isInteger(message.firstFrameMaxSize))
                return "firstFrameMaxSize: integer expected";
        return null;
    };

    /**
     * Creates an ExecuteRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExecuteRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExecuteRequest} ExecuteRequest
     */
    ExecuteRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ExecuteRequest)
            return object;
        let message = new $root.ExecuteRequest();
        if (object.statementHandle != null) {
            if (typeof object.statementHandle !== "object")
                throw TypeError(".ExecuteRequest.statementHandle: object expected");
            message.statementHandle = $root.StatementHandle.fromObject(object.statementHandle);
        }
        if (object.parameterValues) {
            if (!Array.isArray(object.parameterValues))
                throw TypeError(".ExecuteRequest.parameterValues: array expected");
            message.parameterValues = [];
            for (let i = 0; i < object.parameterValues.length; ++i) {
                if (typeof object.parameterValues[i] !== "object")
                    throw TypeError(".ExecuteRequest.parameterValues: object expected");
                message.parameterValues[i] = $root.TypedValue.fromObject(object.parameterValues[i]);
            }
        }
        if (object.deprecatedFirstFrameMaxSize != null)
            if ($util.Long)
                (message.deprecatedFirstFrameMaxSize = $util.Long.fromValue(object.deprecatedFirstFrameMaxSize)).unsigned = true;
            else if (typeof object.deprecatedFirstFrameMaxSize === "string")
                message.deprecatedFirstFrameMaxSize = parseInt(object.deprecatedFirstFrameMaxSize, 10);
            else if (typeof object.deprecatedFirstFrameMaxSize === "number")
                message.deprecatedFirstFrameMaxSize = object.deprecatedFirstFrameMaxSize;
            else if (typeof object.deprecatedFirstFrameMaxSize === "object")
                message.deprecatedFirstFrameMaxSize = new $util.LongBits(object.deprecatedFirstFrameMaxSize.low >>> 0, object.deprecatedFirstFrameMaxSize.high >>> 0).toNumber(true);
        if (object.hasParameterValues != null)
            message.hasParameterValues = Boolean(object.hasParameterValues);
        if (object.firstFrameMaxSize != null)
            message.firstFrameMaxSize = object.firstFrameMaxSize | 0;
        return message;
    };

    /**
     * Creates a plain object from an ExecuteRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExecuteRequest
     * @static
     * @param {ExecuteRequest} message ExecuteRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExecuteRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.parameterValues = [];
        if (options.defaults) {
            object.statementHandle = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.deprecatedFirstFrameMaxSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.deprecatedFirstFrameMaxSize = options.longs === String ? "0" : 0;
            object.hasParameterValues = false;
            object.firstFrameMaxSize = 0;
        }
        if (message.statementHandle != null && message.hasOwnProperty("statementHandle"))
            object.statementHandle = $root.StatementHandle.toObject(message.statementHandle, options);
        if (message.parameterValues && message.parameterValues.length) {
            object.parameterValues = [];
            for (let j = 0; j < message.parameterValues.length; ++j)
                object.parameterValues[j] = $root.TypedValue.toObject(message.parameterValues[j], options);
        }
        if (message.deprecatedFirstFrameMaxSize != null && message.hasOwnProperty("deprecatedFirstFrameMaxSize"))
            if (typeof message.deprecatedFirstFrameMaxSize === "number")
                object.deprecatedFirstFrameMaxSize = options.longs === String ? String(message.deprecatedFirstFrameMaxSize) : message.deprecatedFirstFrameMaxSize;
            else
                object.deprecatedFirstFrameMaxSize = options.longs === String ? $util.Long.prototype.toString.call(message.deprecatedFirstFrameMaxSize) : options.longs === Number ? new $util.LongBits(message.deprecatedFirstFrameMaxSize.low >>> 0, message.deprecatedFirstFrameMaxSize.high >>> 0).toNumber(true) : message.deprecatedFirstFrameMaxSize;
        if (message.hasParameterValues != null && message.hasOwnProperty("hasParameterValues"))
            object.hasParameterValues = message.hasParameterValues;
        if (message.firstFrameMaxSize != null && message.hasOwnProperty("firstFrameMaxSize"))
            object.firstFrameMaxSize = message.firstFrameMaxSize;
        return object;
    };

    /**
     * Converts this ExecuteRequest to JSON.
     * @function toJSON
     * @memberof ExecuteRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExecuteRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ExecuteRequest
     * @function getTypeUrl
     * @memberof ExecuteRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ExecuteRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ExecuteRequest";
    };

    return ExecuteRequest;
})();

export const SyncResultsRequest = $root.SyncResultsRequest = (() => {

    /**
     * Properties of a SyncResultsRequest.
     * @interface ISyncResultsRequest
     * @property {string|null} [connectionId] SyncResultsRequest connectionId
     * @property {number|null} [statementId] SyncResultsRequest statementId
     * @property {IQueryState|null} [state] SyncResultsRequest state
     * @property {number|Long|null} [offset] SyncResultsRequest offset
     */

    /**
     * Constructs a new SyncResultsRequest.
     * @classdesc Represents a SyncResultsRequest.
     * @implements ISyncResultsRequest
     * @constructor
     * @param {ISyncResultsRequest=} [properties] Properties to set
     */
    function SyncResultsRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SyncResultsRequest connectionId.
     * @member {string} connectionId
     * @memberof SyncResultsRequest
     * @instance
     */
    SyncResultsRequest.prototype.connectionId = "";

    /**
     * SyncResultsRequest statementId.
     * @member {number} statementId
     * @memberof SyncResultsRequest
     * @instance
     */
    SyncResultsRequest.prototype.statementId = 0;

    /**
     * SyncResultsRequest state.
     * @member {IQueryState|null|undefined} state
     * @memberof SyncResultsRequest
     * @instance
     */
    SyncResultsRequest.prototype.state = null;

    /**
     * SyncResultsRequest offset.
     * @member {number|Long} offset
     * @memberof SyncResultsRequest
     * @instance
     */
    SyncResultsRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

    /**
     * Creates a new SyncResultsRequest instance using the specified properties.
     * @function create
     * @memberof SyncResultsRequest
     * @static
     * @param {ISyncResultsRequest=} [properties] Properties to set
     * @returns {SyncResultsRequest} SyncResultsRequest instance
     */
    SyncResultsRequest.create = function create(properties) {
        return new SyncResultsRequest(properties);
    };

    /**
     * Encodes the specified SyncResultsRequest message. Does not implicitly {@link SyncResultsRequest.verify|verify} messages.
     * @function encode
     * @memberof SyncResultsRequest
     * @static
     * @param {ISyncResultsRequest} message SyncResultsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncResultsRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.state != null && Object.hasOwnProperty.call(message, "state"))
            $root.QueryState.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.offset);
        return writer;
    };

    /**
     * Encodes the specified SyncResultsRequest message, length delimited. Does not implicitly {@link SyncResultsRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SyncResultsRequest
     * @static
     * @param {ISyncResultsRequest} message SyncResultsRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SyncResultsRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SyncResultsRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SyncResultsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SyncResultsRequest} SyncResultsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncResultsRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SyncResultsRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    message.state = $root.QueryState.decode(reader, reader.uint32());
                    break;
                }
            case 4: {
                    message.offset = reader.uint64();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SyncResultsRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SyncResultsRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SyncResultsRequest} SyncResultsRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SyncResultsRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SyncResultsRequest message.
     * @function verify
     * @memberof SyncResultsRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SyncResultsRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.state != null && message.hasOwnProperty("state")) {
            let error = $root.QueryState.verify(message.state);
            if (error)
                return "state." + error;
        }
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))
                return "offset: integer|Long expected";
        return null;
    };

    /**
     * Creates a SyncResultsRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SyncResultsRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SyncResultsRequest} SyncResultsRequest
     */
    SyncResultsRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SyncResultsRequest)
            return object;
        let message = new $root.SyncResultsRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.state != null) {
            if (typeof object.state !== "object")
                throw TypeError(".SyncResultsRequest.state: object expected");
            message.state = $root.QueryState.fromObject(object.state);
        }
        if (object.offset != null)
            if ($util.Long)
                (message.offset = $util.Long.fromValue(object.offset)).unsigned = true;
            else if (typeof object.offset === "string")
                message.offset = parseInt(object.offset, 10);
            else if (typeof object.offset === "number")
                message.offset = object.offset;
            else if (typeof object.offset === "object")
                message.offset = new $util.LongBits(object.offset.low >>> 0, object.offset.high >>> 0).toNumber(true);
        return message;
    };

    /**
     * Creates a plain object from a SyncResultsRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SyncResultsRequest
     * @static
     * @param {SyncResultsRequest} message SyncResultsRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SyncResultsRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
            object.state = null;
            if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.offset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
                object.offset = options.longs === String ? "0" : 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.state != null && message.hasOwnProperty("state"))
            object.state = $root.QueryState.toObject(message.state, options);
        if (message.offset != null && message.hasOwnProperty("offset"))
            if (typeof message.offset === "number")
                object.offset = options.longs === String ? String(message.offset) : message.offset;
            else
                object.offset = options.longs === String ? $util.Long.prototype.toString.call(message.offset) : options.longs === Number ? new $util.LongBits(message.offset.low >>> 0, message.offset.high >>> 0).toNumber(true) : message.offset;
        return object;
    };

    /**
     * Converts this SyncResultsRequest to JSON.
     * @function toJSON
     * @memberof SyncResultsRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SyncResultsRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SyncResultsRequest
     * @function getTypeUrl
     * @memberof SyncResultsRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SyncResultsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SyncResultsRequest";
    };

    return SyncResultsRequest;
})();

export const CommitRequest = $root.CommitRequest = (() => {

    /**
     * Properties of a CommitRequest.
     * @interface ICommitRequest
     * @property {string|null} [connectionId] CommitRequest connectionId
     */

    /**
     * Constructs a new CommitRequest.
     * @classdesc Represents a CommitRequest.
     * @implements ICommitRequest
     * @constructor
     * @param {ICommitRequest=} [properties] Properties to set
     */
    function CommitRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * CommitRequest connectionId.
     * @member {string} connectionId
     * @memberof CommitRequest
     * @instance
     */
    CommitRequest.prototype.connectionId = "";

    /**
     * Creates a new CommitRequest instance using the specified properties.
     * @function create
     * @memberof CommitRequest
     * @static
     * @param {ICommitRequest=} [properties] Properties to set
     * @returns {CommitRequest} CommitRequest instance
     */
    CommitRequest.create = function create(properties) {
        return new CommitRequest(properties);
    };

    /**
     * Encodes the specified CommitRequest message. Does not implicitly {@link CommitRequest.verify|verify} messages.
     * @function encode
     * @memberof CommitRequest
     * @static
     * @param {ICommitRequest} message CommitRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CommitRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified CommitRequest message, length delimited. Does not implicitly {@link CommitRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof CommitRequest
     * @static
     * @param {ICommitRequest} message CommitRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    CommitRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a CommitRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CommitRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CommitRequest} CommitRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CommitRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CommitRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a CommitRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof CommitRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {CommitRequest} CommitRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CommitRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a CommitRequest message.
     * @function verify
     * @memberof CommitRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    CommitRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a CommitRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof CommitRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {CommitRequest} CommitRequest
     */
    CommitRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.CommitRequest)
            return object;
        let message = new $root.CommitRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a CommitRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof CommitRequest
     * @static
     * @param {CommitRequest} message CommitRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    CommitRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this CommitRequest to JSON.
     * @function toJSON
     * @memberof CommitRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    CommitRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for CommitRequest
     * @function getTypeUrl
     * @memberof CommitRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    CommitRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/CommitRequest";
    };

    return CommitRequest;
})();

export const RollbackRequest = $root.RollbackRequest = (() => {

    /**
     * Properties of a RollbackRequest.
     * @interface IRollbackRequest
     * @property {string|null} [connectionId] RollbackRequest connectionId
     */

    /**
     * Constructs a new RollbackRequest.
     * @classdesc Represents a RollbackRequest.
     * @implements IRollbackRequest
     * @constructor
     * @param {IRollbackRequest=} [properties] Properties to set
     */
    function RollbackRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RollbackRequest connectionId.
     * @member {string} connectionId
     * @memberof RollbackRequest
     * @instance
     */
    RollbackRequest.prototype.connectionId = "";

    /**
     * Creates a new RollbackRequest instance using the specified properties.
     * @function create
     * @memberof RollbackRequest
     * @static
     * @param {IRollbackRequest=} [properties] Properties to set
     * @returns {RollbackRequest} RollbackRequest instance
     */
    RollbackRequest.create = function create(properties) {
        return new RollbackRequest(properties);
    };

    /**
     * Encodes the specified RollbackRequest message. Does not implicitly {@link RollbackRequest.verify|verify} messages.
     * @function encode
     * @memberof RollbackRequest
     * @static
     * @param {IRollbackRequest} message RollbackRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RollbackRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        return writer;
    };

    /**
     * Encodes the specified RollbackRequest message, length delimited. Does not implicitly {@link RollbackRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RollbackRequest
     * @static
     * @param {IRollbackRequest} message RollbackRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RollbackRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RollbackRequest message from the specified reader or buffer.
     * @function decode
     * @memberof RollbackRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RollbackRequest} RollbackRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RollbackRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RollbackRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RollbackRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RollbackRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RollbackRequest} RollbackRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RollbackRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RollbackRequest message.
     * @function verify
     * @memberof RollbackRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RollbackRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        return null;
    };

    /**
     * Creates a RollbackRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RollbackRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RollbackRequest} RollbackRequest
     */
    RollbackRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.RollbackRequest)
            return object;
        let message = new $root.RollbackRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        return message;
    };

    /**
     * Creates a plain object from a RollbackRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RollbackRequest
     * @static
     * @param {RollbackRequest} message RollbackRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RollbackRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults)
            object.connectionId = "";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        return object;
    };

    /**
     * Converts this RollbackRequest to JSON.
     * @function toJSON
     * @memberof RollbackRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RollbackRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RollbackRequest
     * @function getTypeUrl
     * @memberof RollbackRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RollbackRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RollbackRequest";
    };

    return RollbackRequest;
})();

export const PrepareAndExecuteBatchRequest = $root.PrepareAndExecuteBatchRequest = (() => {

    /**
     * Properties of a PrepareAndExecuteBatchRequest.
     * @interface IPrepareAndExecuteBatchRequest
     * @property {string|null} [connectionId] PrepareAndExecuteBatchRequest connectionId
     * @property {number|null} [statementId] PrepareAndExecuteBatchRequest statementId
     * @property {Array.<string>|null} [sqlCommands] PrepareAndExecuteBatchRequest sqlCommands
     */

    /**
     * Constructs a new PrepareAndExecuteBatchRequest.
     * @classdesc Represents a PrepareAndExecuteBatchRequest.
     * @implements IPrepareAndExecuteBatchRequest
     * @constructor
     * @param {IPrepareAndExecuteBatchRequest=} [properties] Properties to set
     */
    function PrepareAndExecuteBatchRequest(properties) {
        this.sqlCommands = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * PrepareAndExecuteBatchRequest connectionId.
     * @member {string} connectionId
     * @memberof PrepareAndExecuteBatchRequest
     * @instance
     */
    PrepareAndExecuteBatchRequest.prototype.connectionId = "";

    /**
     * PrepareAndExecuteBatchRequest statementId.
     * @member {number} statementId
     * @memberof PrepareAndExecuteBatchRequest
     * @instance
     */
    PrepareAndExecuteBatchRequest.prototype.statementId = 0;

    /**
     * PrepareAndExecuteBatchRequest sqlCommands.
     * @member {Array.<string>} sqlCommands
     * @memberof PrepareAndExecuteBatchRequest
     * @instance
     */
    PrepareAndExecuteBatchRequest.prototype.sqlCommands = $util.emptyArray;

    /**
     * Creates a new PrepareAndExecuteBatchRequest instance using the specified properties.
     * @function create
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {IPrepareAndExecuteBatchRequest=} [properties] Properties to set
     * @returns {PrepareAndExecuteBatchRequest} PrepareAndExecuteBatchRequest instance
     */
    PrepareAndExecuteBatchRequest.create = function create(properties) {
        return new PrepareAndExecuteBatchRequest(properties);
    };

    /**
     * Encodes the specified PrepareAndExecuteBatchRequest message. Does not implicitly {@link PrepareAndExecuteBatchRequest.verify|verify} messages.
     * @function encode
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {IPrepareAndExecuteBatchRequest} message PrepareAndExecuteBatchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareAndExecuteBatchRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.sqlCommands != null && message.sqlCommands.length)
            for (let i = 0; i < message.sqlCommands.length; ++i)
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sqlCommands[i]);
        return writer;
    };

    /**
     * Encodes the specified PrepareAndExecuteBatchRequest message, length delimited. Does not implicitly {@link PrepareAndExecuteBatchRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {IPrepareAndExecuteBatchRequest} message PrepareAndExecuteBatchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    PrepareAndExecuteBatchRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a PrepareAndExecuteBatchRequest message from the specified reader or buffer.
     * @function decode
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PrepareAndExecuteBatchRequest} PrepareAndExecuteBatchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareAndExecuteBatchRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PrepareAndExecuteBatchRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    if (!(message.sqlCommands && message.sqlCommands.length))
                        message.sqlCommands = [];
                    message.sqlCommands.push(reader.string());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a PrepareAndExecuteBatchRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {PrepareAndExecuteBatchRequest} PrepareAndExecuteBatchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PrepareAndExecuteBatchRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a PrepareAndExecuteBatchRequest message.
     * @function verify
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    PrepareAndExecuteBatchRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.sqlCommands != null && message.hasOwnProperty("sqlCommands")) {
            if (!Array.isArray(message.sqlCommands))
                return "sqlCommands: array expected";
            for (let i = 0; i < message.sqlCommands.length; ++i)
                if (!$util.isString(message.sqlCommands[i]))
                    return "sqlCommands: string[] expected";
        }
        return null;
    };

    /**
     * Creates a PrepareAndExecuteBatchRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {PrepareAndExecuteBatchRequest} PrepareAndExecuteBatchRequest
     */
    PrepareAndExecuteBatchRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.PrepareAndExecuteBatchRequest)
            return object;
        let message = new $root.PrepareAndExecuteBatchRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.sqlCommands) {
            if (!Array.isArray(object.sqlCommands))
                throw TypeError(".PrepareAndExecuteBatchRequest.sqlCommands: array expected");
            message.sqlCommands = [];
            for (let i = 0; i < object.sqlCommands.length; ++i)
                message.sqlCommands[i] = String(object.sqlCommands[i]);
        }
        return message;
    };

    /**
     * Creates a plain object from a PrepareAndExecuteBatchRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {PrepareAndExecuteBatchRequest} message PrepareAndExecuteBatchRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    PrepareAndExecuteBatchRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.sqlCommands = [];
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.sqlCommands && message.sqlCommands.length) {
            object.sqlCommands = [];
            for (let j = 0; j < message.sqlCommands.length; ++j)
                object.sqlCommands[j] = message.sqlCommands[j];
        }
        return object;
    };

    /**
     * Converts this PrepareAndExecuteBatchRequest to JSON.
     * @function toJSON
     * @memberof PrepareAndExecuteBatchRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    PrepareAndExecuteBatchRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for PrepareAndExecuteBatchRequest
     * @function getTypeUrl
     * @memberof PrepareAndExecuteBatchRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    PrepareAndExecuteBatchRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/PrepareAndExecuteBatchRequest";
    };

    return PrepareAndExecuteBatchRequest;
})();

export const UpdateBatch = $root.UpdateBatch = (() => {

    /**
     * Properties of an UpdateBatch.
     * @interface IUpdateBatch
     * @property {Array.<ITypedValue>|null} [parameterValues] UpdateBatch parameterValues
     */

    /**
     * Constructs a new UpdateBatch.
     * @classdesc Represents an UpdateBatch.
     * @implements IUpdateBatch
     * @constructor
     * @param {IUpdateBatch=} [properties] Properties to set
     */
    function UpdateBatch(properties) {
        this.parameterValues = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * UpdateBatch parameterValues.
     * @member {Array.<ITypedValue>} parameterValues
     * @memberof UpdateBatch
     * @instance
     */
    UpdateBatch.prototype.parameterValues = $util.emptyArray;

    /**
     * Creates a new UpdateBatch instance using the specified properties.
     * @function create
     * @memberof UpdateBatch
     * @static
     * @param {IUpdateBatch=} [properties] Properties to set
     * @returns {UpdateBatch} UpdateBatch instance
     */
    UpdateBatch.create = function create(properties) {
        return new UpdateBatch(properties);
    };

    /**
     * Encodes the specified UpdateBatch message. Does not implicitly {@link UpdateBatch.verify|verify} messages.
     * @function encode
     * @memberof UpdateBatch
     * @static
     * @param {IUpdateBatch} message UpdateBatch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBatch.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.parameterValues != null && message.parameterValues.length)
            for (let i = 0; i < message.parameterValues.length; ++i)
                $root.TypedValue.encode(message.parameterValues[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified UpdateBatch message, length delimited. Does not implicitly {@link UpdateBatch.verify|verify} messages.
     * @function encodeDelimited
     * @memberof UpdateBatch
     * @static
     * @param {IUpdateBatch} message UpdateBatch message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    UpdateBatch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an UpdateBatch message from the specified reader or buffer.
     * @function decode
     * @memberof UpdateBatch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {UpdateBatch} UpdateBatch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBatch.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateBatch();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.parameterValues && message.parameterValues.length))
                        message.parameterValues = [];
                    message.parameterValues.push($root.TypedValue.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an UpdateBatch message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof UpdateBatch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {UpdateBatch} UpdateBatch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    UpdateBatch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an UpdateBatch message.
     * @function verify
     * @memberof UpdateBatch
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    UpdateBatch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.parameterValues != null && message.hasOwnProperty("parameterValues")) {
            if (!Array.isArray(message.parameterValues))
                return "parameterValues: array expected";
            for (let i = 0; i < message.parameterValues.length; ++i) {
                let error = $root.TypedValue.verify(message.parameterValues[i]);
                if (error)
                    return "parameterValues." + error;
            }
        }
        return null;
    };

    /**
     * Creates an UpdateBatch message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UpdateBatch
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {UpdateBatch} UpdateBatch
     */
    UpdateBatch.fromObject = function fromObject(object) {
        if (object instanceof $root.UpdateBatch)
            return object;
        let message = new $root.UpdateBatch();
        if (object.parameterValues) {
            if (!Array.isArray(object.parameterValues))
                throw TypeError(".UpdateBatch.parameterValues: array expected");
            message.parameterValues = [];
            for (let i = 0; i < object.parameterValues.length; ++i) {
                if (typeof object.parameterValues[i] !== "object")
                    throw TypeError(".UpdateBatch.parameterValues: object expected");
                message.parameterValues[i] = $root.TypedValue.fromObject(object.parameterValues[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an UpdateBatch message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UpdateBatch
     * @static
     * @param {UpdateBatch} message UpdateBatch
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    UpdateBatch.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.parameterValues = [];
        if (message.parameterValues && message.parameterValues.length) {
            object.parameterValues = [];
            for (let j = 0; j < message.parameterValues.length; ++j)
                object.parameterValues[j] = $root.TypedValue.toObject(message.parameterValues[j], options);
        }
        return object;
    };

    /**
     * Converts this UpdateBatch to JSON.
     * @function toJSON
     * @memberof UpdateBatch
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    UpdateBatch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for UpdateBatch
     * @function getTypeUrl
     * @memberof UpdateBatch
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    UpdateBatch.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/UpdateBatch";
    };

    return UpdateBatch;
})();

export const ExecuteBatchRequest = $root.ExecuteBatchRequest = (() => {

    /**
     * Properties of an ExecuteBatchRequest.
     * @interface IExecuteBatchRequest
     * @property {string|null} [connectionId] ExecuteBatchRequest connectionId
     * @property {number|null} [statementId] ExecuteBatchRequest statementId
     * @property {Array.<IUpdateBatch>|null} [updates] ExecuteBatchRequest updates
     */

    /**
     * Constructs a new ExecuteBatchRequest.
     * @classdesc Represents an ExecuteBatchRequest.
     * @implements IExecuteBatchRequest
     * @constructor
     * @param {IExecuteBatchRequest=} [properties] Properties to set
     */
    function ExecuteBatchRequest(properties) {
        this.updates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * ExecuteBatchRequest connectionId.
     * @member {string} connectionId
     * @memberof ExecuteBatchRequest
     * @instance
     */
    ExecuteBatchRequest.prototype.connectionId = "";

    /**
     * ExecuteBatchRequest statementId.
     * @member {number} statementId
     * @memberof ExecuteBatchRequest
     * @instance
     */
    ExecuteBatchRequest.prototype.statementId = 0;

    /**
     * ExecuteBatchRequest updates.
     * @member {Array.<IUpdateBatch>} updates
     * @memberof ExecuteBatchRequest
     * @instance
     */
    ExecuteBatchRequest.prototype.updates = $util.emptyArray;

    /**
     * Creates a new ExecuteBatchRequest instance using the specified properties.
     * @function create
     * @memberof ExecuteBatchRequest
     * @static
     * @param {IExecuteBatchRequest=} [properties] Properties to set
     * @returns {ExecuteBatchRequest} ExecuteBatchRequest instance
     */
    ExecuteBatchRequest.create = function create(properties) {
        return new ExecuteBatchRequest(properties);
    };

    /**
     * Encodes the specified ExecuteBatchRequest message. Does not implicitly {@link ExecuteBatchRequest.verify|verify} messages.
     * @function encode
     * @memberof ExecuteBatchRequest
     * @static
     * @param {IExecuteBatchRequest} message ExecuteBatchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteBatchRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.connectionId != null && Object.hasOwnProperty.call(message, "connectionId"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.connectionId);
        if (message.statementId != null && Object.hasOwnProperty.call(message, "statementId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.statementId);
        if (message.updates != null && message.updates.length)
            for (let i = 0; i < message.updates.length; ++i)
                $root.UpdateBatch.encode(message.updates[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified ExecuteBatchRequest message, length delimited. Does not implicitly {@link ExecuteBatchRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof ExecuteBatchRequest
     * @static
     * @param {IExecuteBatchRequest} message ExecuteBatchRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    ExecuteBatchRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes an ExecuteBatchRequest message from the specified reader or buffer.
     * @function decode
     * @memberof ExecuteBatchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ExecuteBatchRequest} ExecuteBatchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteBatchRequest.decode = function decode(reader, length, error) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExecuteBatchRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            if (tag === error)
                break;
            switch (tag >>> 3) {
            case 1: {
                    message.connectionId = reader.string();
                    break;
                }
            case 2: {
                    message.statementId = reader.uint32();
                    break;
                }
            case 3: {
                    if (!(message.updates && message.updates.length))
                        message.updates = [];
                    message.updates.push($root.UpdateBatch.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes an ExecuteBatchRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof ExecuteBatchRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {ExecuteBatchRequest} ExecuteBatchRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ExecuteBatchRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies an ExecuteBatchRequest message.
     * @function verify
     * @memberof ExecuteBatchRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    ExecuteBatchRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            if (!$util.isString(message.connectionId))
                return "connectionId: string expected";
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            if (!$util.isInteger(message.statementId))
                return "statementId: integer expected";
        if (message.updates != null && message.hasOwnProperty("updates")) {
            if (!Array.isArray(message.updates))
                return "updates: array expected";
            for (let i = 0; i < message.updates.length; ++i) {
                let error = $root.UpdateBatch.verify(message.updates[i]);
                if (error)
                    return "updates." + error;
            }
        }
        return null;
    };

    /**
     * Creates an ExecuteBatchRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof ExecuteBatchRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {ExecuteBatchRequest} ExecuteBatchRequest
     */
    ExecuteBatchRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.ExecuteBatchRequest)
            return object;
        let message = new $root.ExecuteBatchRequest();
        if (object.connectionId != null)
            message.connectionId = String(object.connectionId);
        if (object.statementId != null)
            message.statementId = object.statementId >>> 0;
        if (object.updates) {
            if (!Array.isArray(object.updates))
                throw TypeError(".ExecuteBatchRequest.updates: array expected");
            message.updates = [];
            for (let i = 0; i < object.updates.length; ++i) {
                if (typeof object.updates[i] !== "object")
                    throw TypeError(".ExecuteBatchRequest.updates: object expected");
                message.updates[i] = $root.UpdateBatch.fromObject(object.updates[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from an ExecuteBatchRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof ExecuteBatchRequest
     * @static
     * @param {ExecuteBatchRequest} message ExecuteBatchRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    ExecuteBatchRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.updates = [];
        if (options.defaults) {
            object.connectionId = "";
            object.statementId = 0;
        }
        if (message.connectionId != null && message.hasOwnProperty("connectionId"))
            object.connectionId = message.connectionId;
        if (message.statementId != null && message.hasOwnProperty("statementId"))
            object.statementId = message.statementId;
        if (message.updates && message.updates.length) {
            object.updates = [];
            for (let j = 0; j < message.updates.length; ++j)
                object.updates[j] = $root.UpdateBatch.toObject(message.updates[j], options);
        }
        return object;
    };

    /**
     * Converts this ExecuteBatchRequest to JSON.
     * @function toJSON
     * @memberof ExecuteBatchRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    ExecuteBatchRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for ExecuteBatchRequest
     * @function getTypeUrl
     * @memberof ExecuteBatchRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    ExecuteBatchRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/ExecuteBatchRequest";
    };

    return ExecuteBatchRequest;
})();

export { $root as default };
